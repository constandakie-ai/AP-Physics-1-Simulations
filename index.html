<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AP Physics 1 Complete Simulation Suite</title>
    <style>
        /* --- CORE THEME --- */
        :root {
            --primary: #2c3e50;
            --accent: #2980b9;
            --text: #333;
            --bg: #f4f6f7;
            --panel-bg: #ffffff;
            --math-font: 'Times New Roman', serif;
        }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

        /* --- LAYOUT --- */
        #app-container { display: flex; height: 100%; }

        /* SIDEBAR NAVIGATION */
        aside { width: 260px; background: var(--primary); color: white; display: flex; flex-direction: column; overflow-y: auto; flex-shrink: 0; }
        aside h1 { padding: 20px; font-size: 1.2rem; margin: 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .unit-header { padding: 15px 20px; font-weight: bold; background: rgba(0,0,0,0.2); cursor: pointer; display: flex; justify-content: space-between; font-size: 0.9rem; }
        .unit-header:hover { background: rgba(0,0,0,0.3); }
        .sub-menu { display: none; background: #34495e; }
        .sub-menu.open { display: block; }
        .nav-btn { width: 100%; text-align: left; padding: 12px 30px; background: none; border: none; color: #bdc3c7; cursor: pointer; font-size: 0.85rem; transition: 0.2s; border-left: 3px solid transparent; }
        .nav-btn:hover { color: white; background: rgba(255,255,255,0.05); }
        .nav-btn.active { color: white; border-left-color: var(--accent); background: rgba(0,0,0,0.2); }

        /* MAIN CONTENT AREA */
        main { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 20px; }

        /* SIMULATION CONTAINER */
        .sim-container { display: flex; gap: 20px; flex-wrap: wrap; align-items: flex-start; }
        .canvas-area { position: relative; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 15px rgba(0,0,0,0.1); background: white; }
        canvas { display: block; cursor: crosshair; }

        /* CONTROLS PANEL */
        .controls { background: var(--panel-bg); padding: 20px; border-radius: 8px; width: 300px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); flex-shrink: 0; }
        .control-group { margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        label { display: flex; justify-content: space-between; font-size: 0.9rem; font-weight: 500; margin-bottom: 5px; color: #555; }
        input[type=range] { width: 100%; cursor: pointer; }

        /* DESCRIPTION BOX */
        .desc-box { background: white; padding: 20px; border-radius: 8px; border-left: 5px solid var(--accent); line-height: 1.6; color: #444; max-width: 900px; }
        .desc-box h3 { margin-top: 0; color: var(--primary); }

        /* MATH TYPOGRAPHY */
        .var { font-family: var(--math-font); font-style: italic; }
        .unit { font-family: sans-serif; font-style: normal; font-size: 0.85em; color: #7f8c8d; }

        /* UTILITY CLASSES */
        .hidden { display: none !important; }
        .btn { width: 100%; padding: 10px; border: none; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; margin-top: 5px; }
        .btn-green { background: #27ae60; } .btn-green:hover { background: #219150; }
        .btn-red { background: #c0392b; } .btn-red:hover { background: #a93226; }

        /* DATA READOUT */
        .readout { font-family: monospace; background: #eee; padding: 10px; border-radius: 4px; margin-top: 10px; font-size: 0.85rem; }

        /* --- THEME VARIATIONS --- */
        /* Space Theme for Unit 3 */
        .theme-space .canvas-area { background: #000; border: 1px solid #333; }
        .theme-space .controls { background: #1a1a1a; color: #ddd; }
        .theme-space label { color: #bbb; }
        .theme-space .readout { background: #333; color: #0f0; }

        /* Lab Theme for Unit 2 */
        .theme-lab .canvas-area { background: #f0f3f5; border: 4px solid #bdc3c7; }
    </style>
</head>
<body>

<div id="app-container">
    <aside>
        <h1>AP Physics 1 Lab</h1>

        <div class="unit-header" onclick="toggleMenu('u1-menu')">Unit 1: Kinematics <span>▼</span></div>
        <div id="u1-menu" class="sub-menu">
            <button class="nav-btn" onclick="loadSim('1.1')">1.1 Position & Velocity</button>
            <button class="nav-btn" onclick="loadSim('1.2')">1.2 Acceleration (1D)</button>
            <button class="nav-btn" onclick="loadSim('1.3')">1.3 Projectile Motion</button>
            <button class="nav-btn" onclick="loadSim('1.4')">1.4 Relative Motion (River)</button>
            <button class="nav-btn" onclick="loadSim('1.5')">1.5 Graph Matching Game</button>
        </div>

        <div class="unit-header" onclick="toggleMenu('u2-menu')">Unit 2: Dynamics <span>▼</span></div>
        <div id="u2-menu" class="sub-menu">
            <button class="nav-btn" onclick="loadSim('2.1')">2.1 Newton's 2nd Law</button>
            <button class="nav-btn" onclick="loadSim('2.2')">2.2 Inclined Planes</button>
            <button class="nav-btn" onclick="loadSim('2.3')">2.3 Connected Systems</button>
            <button class="nav-btn" onclick="loadSim('2.4')">2.4 Static vs. Kinetic Friction</button>
            <button class="nav-btn" onclick="loadSim('2.5')">2.5 Apparent Weight (Elevator)</button>
            <button class="nav-btn" onclick="loadSim('2.6')">2.6 Drag & Terminal Velocity</button>
        </div>

        <div class="unit-header" onclick="toggleMenu('u3-menu')">Unit 3: Circ. Motion <span>▼</span></div>
        <div id="u3-menu" class="sub-menu">
            <button class="nav-btn" onclick="loadSim('3.1')">3.1 Uniform Circ. Motion</button>
            <button class="nav-btn" onclick="loadSim('3.2')">3.2 Gravitation & Orbits</button>
            <button class="nav-btn" onclick="loadSim('3.3')">3.3 Vertical Circles (Loop)</button>
        </div>

<div class="unit-header" onclick="toggleMenu('u4-menu')">Unit 4: Energy <span>▼</span></div>
        <div id="u4-menu" class="sub-menu">
            <button class="nav-btn" onclick="loadSim('4.1')">4.1 Conservation of Energy</button>
            <button class="nav-btn" onclick="loadSim('4.2')">4.2 Work & Power</button>
            <button class="nav-btn" onclick="loadSim('4.3')">4.3 Elastic Potential Energy</button>
        </div>

<div class="unit-header" onclick="toggleMenu('u5-menu')">Unit 5: Momentum <span>▼</span></div>
<div id="u5-menu" class="sub-menu">
    <button class="nav-btn" onclick="loadSim('5.1')">5.1 Momentum & Impulse</button>
    <button class="nav-btn" onclick="loadSim('5.2')">5.2 Conservation of Momentum</button>
</div>

        <div class="unit-header" onclick="toggleMenu('u6-menu')">Unit 6: SHM <span>▼</span></div>
        <div id="u6-menu" class="sub-menu">
            <button class="nav-btn" onclick="loadSim('6.1')">6.1 Spring Mass Systems</button>
            <button class="nav-btn" onclick="loadSim('6.2')">6.2 The Pendulum</button>
        </div>

<div class="unit-header" onclick="toggleMenu('u7-menu')">Unit 7: Torque & Rotation <span>▼</span></div>
<div id="u7-menu" class="sub-menu">
    <button class="nav-btn" onclick="loadSim('7.1')">7.1 Torque & Equilibrium</button>
    <button class="nav-btn" onclick="loadSim('7.2')">7.2 Rotational Inertia & Ang. Momentum</button>
    <button class="nav-btn" onclick="loadSim('7.3')">7.3 Rotational Kinematics</button>
</div>
    </aside>

    <main id="main-view">
        <h2 id="sim-title" style="margin-top:0; color: var(--primary);">Welcome</h2>

        <div id="sim-desc" class="desc-box">
            Select a simulation from the menu to begin.
        </div>

        <div class="sim-container hidden" id="sim-interface">
            <div class="canvas-area">
                <canvas id="sim-canvas" width="700" height="450"></canvas>
            </div>

            <div id="sim-controls" class="controls"></div>
        </div>
    </main>
</div>

<script>
    // === GLOBAL ENGINE ===
    const canvas = document.getElementById('sim-canvas');
    const ctx = canvas.getContext('2d');
    let currentSim = null;
    let animId = null;

    // Sim State Object (Reset on every load)
    let state = {};

    function toggleMenu(id) {
        document.getElementById(id).classList.toggle('open');
    }

    function stopSim() {
        if(animId) cancelAnimationFrame(animId);
        animId = null;
    }

    // === SIMULATION LOADER ===
    function loadSim(id) {
        stopSim();
        currentSim = id;

        // UI Reset
        document.getElementById('sim-interface').classList.remove('hidden');
        document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active'); // Highlight button
        document.getElementById('main-view').className = ''; // Reset themes

        // Logic Switch
        switch(id) {
            case '1.1': setup_1_1(); break;
            case '1.2': setup_1_2(); break;
            case '1.3': setup_1_3(); break;
            case '1.4': setup_1_4(); break; // New River Boat
            case '1.5': setup_1_5(); break; // New Graph Match
            case '2.1': setup_2_1(); break;
            case '2.2': setup_2_2(); break;
            case '2.3': setup_2_3(); break;
            case '2.4': setup_2_4(); break; // New Friction Lab
            case '2.5': setup_2_5(); break; // New Elevator Lab
            case '2.6': setup_2_6(); break; // New Terminal Velocity
            case '3.1': setup_3_1(); break;
            case '3.2': setup_3_2(); break;
            case '3.3': setup_3_3(); break; // New Vertical Circle
            case '4.1': setup_4_1(); break;
            case '4.2': setup_4_2(); break; // New Work Lab
            case '4.3': setup_4_3(); break; // New Spring Energy
            case '5.1': setup_5_1(); break; // Now Impulse
            case '5.2': setup_5_2(); break; // Now Conservation (Old 5.1)
            case '6.1': setup_6_1(); break;
            case '6.2': setup_6_2(); break; // New Pendulum
            case '7.1': setup_7_1(); break; // Torque (Seesaw)
            case '7.2': setup_7_2(); break; // Rotational Inertia (New)
            case '7.3': setup_7_3(); break; // New Rotational Kinematics
        }
    }
    // Load Default
    loadSim('1.1');
    
    // ===============================================
    // === UNIT 1: KINEMATICS (Clean, Vector Focus) ===
    // ===============================================

    // --- 1.1 Position & Velocity ---
    function setup_1_1() {
        document.getElementById('sim-title').innerText = "1.1 Position and Constant Velocity";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Understanding Displacement</h3>
            <p>This simulation visualizes the relationship between position (<span class="var">x</span>) and constant velocity (<span class="var">v</span>). 
            Observe how the velocity vector (red arrow) dictates the rate of change of the position vector (blue arrow).
            The motion is 1-Dimensional.</p>`;

        // Controls
        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Velocity (<i class="var">v</i>): <span id="val-v">5</span> m/s</label>
                <input type="range" id="in-v" min="-10" max="10" value="5" oninput="state.v=parseFloat(this.value); updateReadout()">
            </div>
            <div class="control-group">
                <label>Start Pos (<i class="var">x<sub>0</sub></i>): <span id="val-x">0</span> m</label>
                <input type="range" id="in-x" min="-50" max="50" value="0" oninput="state.x=parseFloat(this.value); updateReadout(); draw_1_1()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_1_1()">Start / Stop</button>
            <div class="readout">Time: <span id="out-t">0.0</span>s <br> Pos: <span id="out-x">0.0</span>m</div>
        `;

        // Init State
        state = { x: 0, v: 5, t: 0, running: false };
        draw_1_1();
    }

    function loop_1_1() {
        if(!state.running || currentSim !== '1.1') return;
        state.t += 0.02;
        state.x += state.v * 0.02;
        updateReadout();
        draw_1_1();
        animId = requestAnimationFrame(loop_1_1);
    }

    function draw_1_1() {
        ctx.clearRect(0,0,700,450);
        // Grid
        drawGrid(50);
        // Axis
        ctx.beginPath(); ctx.moveTo(0, 225); ctx.lineTo(700, 225); ctx.stroke();

        // Object
        let px = 350 + (state.x * 5); // Scale 5px = 1m
        drawCar(px, 225, state.v);

        // Position Vector
        drawVector(350, 225, px - 350, 0, "blue", "x");
    }

    // --- 1.3 Projectile Motion ---
    function setup_1_3() {
        document.getElementById('sim-title').innerText = "1.3 Projectile Motion";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Independence of Motion</h3>
            <p>Projectiles move in two dimensions simultaneously. The horizontal motion (<span class="var">x</span>) is constant velocity, while the vertical motion (<span class="var">y</span>) is affected by gravity (<span class="var">g</span>). 
            Use this tool to separate components and visualize the trajectory.</p>`;

        document.getElementById('sim-controls').innerHTML = `
             <div class="control-group">
                <label>Initial V (<i class="var">v<sub>i</sub></i>): <span id="val-vi">25</span> m/s</label>
                <input type="range" id="in-vi" min="10" max="40" value="25" oninput="state.vi=parseFloat(this.value); reset_1_3()">
            </div>
            <div class="control-group">
                <label>Angle (<i class="var">&theta;</i>): <span id="val-th">45</span>&deg;</label>
                <input type="range" id="in-th" min="0" max="90" value="45" oninput="state.th=parseFloat(this.value); reset_1_3()">
            </div>
            <button class="btn btn-green" onclick="state.running=true; loop_1_3()">Launch</button>
            <button class="btn btn-red" onclick="reset_1_3()">Reset</button>
            <div class="readout">Range: <span id="out-r">0.0</span>m <br> Height: <span id="out-h">0.0</span>m</div>
        `;
        reset_1_3();
    }

    function reset_1_3() {
        state = { 
            vi: parseFloat(document.getElementById('in-vi')?.value || 25), 
            th: parseFloat(document.getElementById('in-th')?.value || 45),
            t: 0, x: 0, y: 0, running: false, trail: [] 
        };
        // Update labels
        document.getElementById('val-vi').innerText = state.vi;
        document.getElementById('val-th').innerText = state.th;
        draw_1_3();
    }

    function loop_1_3() {
        if(!state.running || currentSim !== '1.3') return;
        let dt = 0.05;
        state.t += dt;
        let rad = state.th * Math.PI/180;

        // Physics
        state.x = (state.vi * Math.cos(rad)) * state.t;
        state.y = (state.vi * Math.sin(rad) * state.t) - (0.5 * 9.8 * state.t**2);

        state.trail.push({x: state.x, y: state.y});

        if(state.y < 0) { state.y = 0; state.running = false; }

        // Data
        document.getElementById('out-r').innerText = state.x.toFixed(1);
        document.getElementById('out-h').innerText = Math.max(0, state.y).toFixed(1);

        draw_1_3();
        if(state.running) animId = requestAnimationFrame(loop_1_3);
    }

    function draw_1_3() {
        ctx.clearRect(0,0,700,450);
        // Ground
        ctx.fillStyle = "#ecf0f1"; ctx.fillRect(0, 400, 700, 50);

        // Trajectory
        ctx.beginPath(); ctx.strokeStyle = "#95a5a6"; ctx.setLineDash([5,5]);
        state.trail.forEach((p,i) => {
            let sx = 20 + p.x * 5; let sy = 400 - p.y * 5;
            if(i==0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
        });
        ctx.stroke(); ctx.setLineDash([]);

        // Ball
        let sx = 20 + state.x * 5;
        let sy = 400 - state.y * 5;
        ctx.fillStyle = "#e74c3c"; ctx.beginPath(); ctx.arc(sx, sy, 6, 0, Math.PI*2); ctx.fill();

        // Component Vectors
        if(state.running || state.y > 0) {
            let vx = state.vi * Math.cos(state.th * Math.PI/180);
            let vy = state.vi * Math.sin(state.th * Math.PI/180) - (9.8 * state.t);
            drawVector(sx, sy, vx*2, 0, "blue"); // Vx
            drawVector(sx, sy, 0, -vy*2, "green"); // Vy (Note: negative y is up in canvas logic for vectors usually, but here sy is canvas coord)
        }
    }

    // ===============================================
    // === UNIT 2: DYNAMICS (Lab Bench Theme) ===
    // ===============================================

    function setup_2_2() {
        document.getElementById('main-view').classList.add('theme-lab'); // CSS class
        document.getElementById('sim-title').innerText = "2.2 Inclined Planes";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Forces on a Slope</h3>
            <p>On an incline, gravity (<span class="var">F<sub>g</sub></span>) is resolved into perpendicular and parallel components. 
            Friction (<span class="var">F<sub>f</sub></span>) opposes motion. Adjust the coefficient of friction (<span class="var">&mu;</span>) and angle (<span class="var">&theta;</span>) to see if the block slides.</p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Mass (<i class="var">m</i>): <span id="val-m">2</span> kg</label>
                <input type="range" id="in-m" min="1" max="10" value="2" oninput="state.m=parseFloat(this.value); draw_2_2()">
            </div>
            <div class="control-group">
                <label>Angle (<i class="var">&theta;</i>): <span id="val-a">30</span>&deg;</label>
                <input type="range" id="in-a" min="0" max="60" value="30" oninput="state.angle=parseFloat(this.value); draw_2_2()">
            </div>
            <div class="control-group">
                <label>Friction (<i class="var">&mu;</i>): <span id="val-mu">0.3</span></label>
                <input type="range" id="in-mu" min="0" max="1.0" step="0.1" value="0.3" oninput="state.mu=parseFloat(this.value); draw_2_2()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_2_2()">Slide</button>
            <div class="readout">Net Force: <span id="out-f">0.0</span> N</div>
        `;

        state = { m: 2, angle: 30, mu: 0.3, x: 0, v: 0, running: false };
        draw_2_2();
    }

    function loop_2_2() {
        if(!state.running || currentSim !== '2.2') return;

        let g = 9.8;
        let rad = state.angle * Math.PI/180;
        let Fgx = state.m * g * Math.sin(rad);
        let Fgy = state.m * g * Math.cos(rad); // Normal force = Fgy
        let Ff = state.mu * Fgy;

        let Fnet = Fgx - Ff;
        if(Fnet < 0) Fnet = 0; // Static friction prevents moving up

        let a = Fnet / state.m;
        state.v += a * 0.02;
        state.x += state.v * 0.02;

        document.getElementById('out-f').innerText = Fnet.toFixed(2);

        if(state.x > 8) state.running = false; // End of ramp

        draw_2_2();
        animId = requestAnimationFrame(loop_2_2);
    }

    function draw_2_2() {
        // Lab Bench background
        ctx.fillStyle = "#f0f3f5"; ctx.fillRect(0,0,700,450);

        let rad = state.angle * Math.PI/180;
        let cx = 100, cy = 400;

        // Ramp
        ctx.fillStyle = "#bdc3c7"; 
        ctx.beginPath(); ctx.moveTo(cx, cy); 
        ctx.lineTo(cx + 500*Math.cos(rad), cy - 500*Math.sin(rad)); 
        ctx.lineTo(cx + 500*Math.cos(rad), cy); 
        ctx.fill();

        // Block Rotation Logic
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(-rad);

        let bx = state.x * 50 + 50; // px
        ctx.fillStyle = "#e67e22"; ctx.fillRect(bx, -40, 40, 40);

        // FBD
        let cenX = bx + 20; let cenY = -20;
        // Normal (Up relative to slope)
        drawVector(cenX, cenY, 0, -60, "blue"); 
        // Friction (Left relative to slope)
        if(state.mu > 0) drawVector(cenX, cenY, -40, 0, "red");

        ctx.restore();

        // Gravity (Always down in world space)
        // Need to project block center to world space
        let wx = cx + (bx+20)*Math.cos(rad) - (-20)*Math.sin(rad); // Simple approx
        // Actually: rotated x is bx+20, y is -20.
        let worldX = cx + (bx+20) * Math.cos(rad) - (-20) * Math.sin(rad); // Rotation matrix
        let worldY = cy + (bx+20) * Math.sin(-rad) + (-20) * Math.cos(-rad); // Note the -rad for canvas y flip? No, standard rot.
        // Simplified visual anchor:
        let visX = cx + (state.x*50 + 70)*Math.cos(rad);
        let visY = cy - (state.x*50 + 70)*Math.sin(rad);
        drawVector(visX, visY, 0, 60, "green"); // Gravity straight down
    }

    // ===============================================
    // === UNIT 3: CIRCULAR MOTION (Space Theme) ===
    // ===============================================

    function setup_3_2() {
        document.getElementById('main-view').classList.add('theme-space');
        document.getElementById('sim-title').innerText = "3.2 Universal Gravitation & Orbits";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Orbit Simulation</h3>
            <p>The gravitational force (<span class="var">F<sub>g</sub></span>) provides the centripetal force required to keep a satellite in orbit. 
            If velocity (<span class="var">v</span>) is too high, the satellite escapes. If too low, it crashes.
            <br><i>Equation:</i> <span class="var">F<sub>g</sub> = Gm<sub>1</sub>m<sub>2</sub> / r<sup>2</sup></span></p>`;

        document.getElementById('sim-controls').innerHTML = `
             <div class="control-group">
                <label>Orbital Velocity (<span class="var">v</span>)</label>
                <input type="range" id="in-ov" min="0" max="10" step="0.1" value="4.5" oninput="reset_3_2()">
            </div>
             <div class="control-group">
                <label>Distance (<span class="var">r</span>)</label>
                <input type="range" id="in-or" min="50" max="200" value="120" oninput="reset_3_2()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_3_2()">Play / Pause</button>
            <button class="btn btn-red" onclick="reset_3_2()">Reset</button>
        `;
        reset_3_2();
    }

    function reset_3_2() {
        let r = parseFloat(document.getElementById('in-or').value);
        let v = parseFloat(document.getElementById('in-ov').value);
        state = { 
            sunM: 1000, 
            planetX: r, planetY: 0, 
            vx: 0, vy: v, 
            trail: [], running: false 
        };
        draw_3_2();
    }

    function loop_3_2() {
        if(!state.running || currentSim !== '3.2') return;

        // Euler Integration for Orbits (Simple)
        let r2 = state.planetX**2 + state.planetY**2;
        let r = Math.sqrt(r2);
        let F = 5000 / r2; // G*M simplified to 5000 for visual scaling

        let angle = Math.atan2(state.planetY, state.planetX);
        let ax = -F * Math.cos(angle);
        let ay = -F * Math.sin(angle);

        state.vx += ax;
        state.vy += ay;
        state.planetX += state.vx;
        state.planetY += state.vy;

        state.trail.push({x: state.planetX, y: state.planetY});
        if(state.trail.length > 200) state.trail.shift();

        // Crash check
        if(r < 20) state.running = false; 

        draw_3_2();
        animId = requestAnimationFrame(loop_3_2);
    }

    function draw_3_2() {
        ctx.fillStyle = "#000000"; ctx.fillRect(0,0,700,450);

        let cx = 350, cy = 225; // Center of canvas

        // Star
        ctx.fillStyle = "#f1c40f"; 
        ctx.beginPath(); ctx.arc(cx, cy, 20, 0, Math.PI*2); ctx.fill();
        // Glow
        ctx.strokeStyle = "rgba(241, 196, 15, 0.2)"; ctx.lineWidth=10; ctx.stroke(); ctx.lineWidth=1;

        // Trail
        ctx.strokeStyle = "#3498db"; ctx.beginPath();
        state.trail.forEach((p, i) => {
            if(i==0) ctx.moveTo(cx + p.x, cy + p.y);
            else ctx.lineTo(cx + p.x, cy + p.y);
        });
        ctx.stroke();

        // Planet
        let px = cx + state.planetX;
        let py = cy + state.planetY;
        ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(px, py, 5, 0, Math.PI*2); ctx.fill();

        // Force Vector (Gravity)
        let angle = Math.atan2(state.planetY, state.planetX);
        let Flen = 30; // Visual length
        drawVector(px, py, -Flen*Math.cos(angle), -Flen*Math.sin(angle), "red");

        // Velocity Vector
        drawVector(px, py, state.vx*5, state.vy*5, "green");
    }

    // === UTILITY HELPERS ===

    // Updates the text numbers in the UI
    function updateReadout() {
        if(document.getElementById('out-t')) document.getElementById('out-t').innerText = state.t.toFixed(2);
        if(document.getElementById('out-x')) document.getElementById('out-x').innerText = state.x.toFixed(2);
        if(document.getElementById('val-v')) document.getElementById('val-v').innerText = state.v;
        if(document.getElementById('val-x')) document.getElementById('val-x').innerText = state.x;
    }

// ===============================================
    // === UNIT 1.2: ACCELERATION (Graph Focus) ===
    // ===============================================
    function setup_1_2() {
        document.getElementById('sim-title').innerText = "1.2 Accelerated Motion";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Changing Velocity</h3>
            <p>When velocity changes, we have acceleration (<span class="var">a</span>). 
            Positive acceleration speeds up an object moving in the positive direction, while negative acceleration (deceleration) slows it down.
            Observe how the spacing between the "bread crumb" trail dots increases as speed increases.</p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Initial Vel (<i class="var">v<sub>0</sub></i>): <span id="val-v0">0</span> m/s</label>
                <input type="range" id="in-v0" min="0" max="10" value="0" step="0.5" oninput="reset_1_2()">
            </div>
            <div class="control-group">
                <label>Accel (<i class="var">a</i>): <span id="val-a">1.0</span> m/s²</label>
                <input type="range" id="in-a" min="-2" max="2" value="1.0" step="0.1" oninput="reset_1_2()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_1_2()">Start / Stop</button>
            <button class="btn btn-red" onclick="reset_1_2()">Reset</button>
            <div class="readout">Vel (<i class="var">v</i>): <span id="out-v">0.0</span> m/s <br> Pos (<i class="var">x</i>): <span id="out-x">0.0</span> m</div>
        `;
        reset_1_2();
    }

    function reset_1_2() {
        state = { 
            v0: parseFloat(document.getElementById('in-v0').value), 
            a: parseFloat(document.getElementById('in-a').value),
            x: 0, v: 0, t: 0, running: false, trail: [] 
        };
        state.v = state.v0;
        document.getElementById('val-v0').innerText = state.v0;
        document.getElementById('val-a').innerText = state.a;
        updateReadout_1_2();
        draw_1_2();
    }

    function loop_1_2() {
        if(!state.running || currentSim !== '1.2') return;
        let dt = 0.05;
        state.t += dt;

        // Kinematics: v = v0 + at
        state.v = state.v0 + (state.a * state.t);
        // x = x0 + v0t + 0.5at^2
        state.x = (state.v0 * state.t) + (0.5 * state.a * state.t * state.t);

        // Trail logic (drop a dot every 0.5 seconds)
        if (Math.floor(state.t / 0.5) > state.trail.length) {
            state.trail.push(state.x);
        }

        updateReadout_1_2();
        draw_1_2();

        // Stop if off screen
        if(state.x > 65 || state.x < -5) state.running = false;
        else animId = requestAnimationFrame(loop_1_2);
    }

    function updateReadout_1_2() {
        document.getElementById('out-v').innerText = state.v.toFixed(2);
        document.getElementById('out-x').innerText = state.x.toFixed(2);
    }

    function draw_1_2() {
        ctx.clearRect(0,0,700,450);
        drawGrid(50);

        // Ground line
        ctx.beginPath(); ctx.moveTo(0, 250); ctx.lineTo(700, 250); ctx.stroke();

        // Motion Map (Breadcrumbs)
        ctx.fillStyle = "rgba(46, 204, 113, 0.5)";
        state.trail.forEach(pos => {
            let px = 50 + pos * 10;
            ctx.beginPath(); ctx.arc(px, 250, 4, 0, Math.PI*2); ctx.fill();
        });

        // Car
        let cx = 50 + state.x * 10; // Scale 10px = 1m
        drawCar(cx, 250, state.v);

        // Acceleration Vector (Orange) above car
        if (Math.abs(state.a) > 0.1) {
            drawVector(cx, 200, state.a * 20, 0, "#e67e22");
            ctx.fillStyle = "#e67e22"; ctx.fillText("a", cx-5, 190);
        }
    }

    // ===============================================
    // === UNIT 2.1: NEWTON'S 2ND LAW (Lab Bench) ===
    // ===============================================
    function setup_2_1() {
        document.getElementById('main-view').classList.add('theme-lab');
        document.getElementById('sim-title').innerText = "2.1 Newton's Second Law";
        document.getElementById('sim-desc').innerHTML = `
            <h3>F = ma</h3>
            <p>Acceleration is directly proportional to Net Force (<span class="var">F<sub>net</sub></span>) and inversely proportional to Mass (<span class="var">m</span>).
            <br>In this frictionless environment, apply a force to see the resulting acceleration.</p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Force (<i class="var">F</i>): <span id="val-f">10</span> N</label>
                <input type="range" id="in-f" min="-50" max="50" value="10" oninput="reset_2_1()">
            </div>
            <div class="control-group">
                <label>Mass (<i class="var">m</i>): <span id="val-m">5</span> kg</label>
                <input type="range" id="in-m" min="1" max="20" value="5" oninput="reset_2_1()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_2_1()">Push</button>
            <button class="btn btn-red" onclick="reset_2_1()">Reset</button>
            <div class="readout">Accel (<i class="var">a</i>): <span id="out-a">2.00</span> m/s²</div>
        `;
        reset_2_1();
    }

    function reset_2_1() {
        state = { 
            F: parseFloat(document.getElementById('in-f').value), 
            m: parseFloat(document.getElementById('in-m').value),
            x: 0, v: 0, running: false 
        };
        state.a = state.F / state.m;

        document.getElementById('val-f').innerText = state.F;
        document.getElementById('val-m').innerText = state.m;
        document.getElementById('out-a').innerText = state.a.toFixed(2);
        draw_2_1();
    }

    function loop_2_1() {
        if(!state.running || currentSim !== '2.1') return;
        state.v += state.a * 0.05;
        state.x += state.v * 0.05;

        // Wall bounce
        if (state.x > 250 || state.x < -250) {
            state.v = -state.v * 0.5; // lose energy
            state.x = state.x > 0 ? 250 : -250;
            state.running = false;
        }

        draw_2_1();
        animId = requestAnimationFrame(loop_2_1);
    }

    function draw_2_1() {
        ctx.clearRect(0,0,700,450);
        ctx.fillStyle = "#f0f3f5"; ctx.fillRect(0,0,700,450); // Lab bg

        // Ice surface
        ctx.fillStyle = "#d1e8ff"; ctx.fillRect(50, 280, 600, 20);

        let cx = 350 + state.x;
        let cy = 280 - (state.m * 2); // Box size based on mass
        let size = state.m * 4; 
        if(size < 30) size = 30; // Min size

        // Block
        ctx.fillStyle = "#e74c3c"; ctx.fillRect(cx - size/2, 280 - size, size, size);
        ctx.strokeStyle = "#c0392b"; ctx.strokeRect(cx - size/2, 280 - size, size, size);

        // Text on block
        ctx.fillStyle = "white"; ctx.textAlign = "center"; 
        ctx.font = "bold 14px sans-serif"; ctx.fillText(state.m + "kg", cx, 280 - size/2 + 5);

        // Force Vector
        if (Math.abs(state.F) > 0) {
            drawVector(cx, 280 - size/2, state.F * 3, 0, "black");
            ctx.fillStyle = "black"; ctx.fillText("F", cx + state.F*3, 280 - size/2 - 10);
        }
    }

    // ===============================================
    // === UNIT 2.3: CONNECTED SYSTEMS (Atwood) ===
    // ===============================================
    function setup_2_3() {
        document.getElementById('main-view').classList.add('theme-lab');
        document.getElementById('sim-title').innerText = "2.3 Connected Systems (Atwood Machine)";
        document.getElementById('sim-desc').innerHTML = `
            <h3>System Acceleration</h3>
            <p>Two masses connected by a string over a pulley. The system accelerates based on the difference in mass.
            <br>Equation: <span class="var">a = g(m<sub>2</sub> - m<sub>1</sub>) / (m<sub>1</sub> + m<sub>2</sub>)</span></p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Mass 1 (Left): <span id="val-m1">2</span> kg</label>
                <input type="range" id="in-m1" min="1" max="10" value="2" oninput="reset_2_3()">
            </div>
            <div class="control-group">
                <label>Mass 2 (Right): <span id="val-m2">4</span> kg</label>
                <input type="range" id="in-m2" min="1" max="10" value="4" oninput="reset_2_3()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_2_3()">Release</button>
            <button class="btn btn-red" onclick="reset_2_3()">Reset</button>
            <div class="readout">Accel (<i class="var">a</i>): <span id="out-a">0.00</span> m/s²</div>
        `;
        reset_2_3();
    }

    function reset_2_3() {
        state = { 
            m1: parseFloat(document.getElementById('in-m1').value), 
            m2: parseFloat(document.getElementById('in-m2').value),
            pos: 0, v: 0, running: false 
        };
        // Calc acceleration
        let g = 9.8;
        state.a = g * (state.m2 - state.m1) / (state.m1 + state.m2);

        document.getElementById('val-m1').innerText = state.m1;
        document.getElementById('val-m2').innerText = state.m2;
        document.getElementById('out-a').innerText = Math.abs(state.a).toFixed(2);
        draw_2_3();
    }

    function loop_2_3() {
        if(!state.running || currentSim !== '2.3') return;
        state.v += state.a * 0.05;
        state.pos += state.v * 0.05;

        // Floor Limits
        if(state.pos > 150 || state.pos < -150) state.running = false;

        draw_2_3();
        animId = requestAnimationFrame(loop_2_3);
    }

    function draw_2_3() {
        ctx.clearRect(0,0,700,450);
        ctx.fillStyle = "#f0f3f5"; ctx.fillRect(0,0,700,450);

        // Pulley
        let cx = 350, cy = 50;
        ctx.beginPath(); ctx.arc(cx, cy, 30, 0, Math.PI*2); 
        ctx.fillStyle = "#333"; ctx.fill();

        // String
        ctx.strokeStyle = "black"; ctx.lineWidth = 2;
        ctx.beginPath();
        // Left String
        ctx.moveTo(cx - 30, cy); ctx.lineTo(cx - 30, cy + 150 - state.pos);
        // Right String
        ctx.moveTo(cx + 30, cy); ctx.lineTo(cx + 30, cy + 150 + state.pos);
        ctx.stroke();

        // Masses
        let y1 = cy + 150 - state.pos;
        let y2 = cy + 150 + state.pos;
        let s1 = 20 + state.m1 * 3;
        let s2 = 20 + state.m2 * 3;

        // Draw M1
        ctx.fillStyle = "#3498db"; ctx.fillRect(cx - 30 - s1/2, y1, s1, s1);
        ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.fillText("m1", cx - 30, y1+s1/2+5);

        // Draw M2
        ctx.fillStyle = "#e74c3c"; ctx.fillRect(cx + 30 - s2/2, y2, s2, s2);
        ctx.fillStyle = "white"; ctx.fillText("m2", cx + 30, y2+s2/2+5);
    }


    // ===============================================
    // === UNIT 3.1: CIRCULAR MOTION (Vector View) ===
    // ===============================================
    function setup_3_1() {
        document.getElementById('main-view').classList.add('theme-space');
        document.getElementById('sim-title').innerText = "3.1 Uniform Circular Motion";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Velocity vs Acceleration</h3>
            <p>In Uniform Circular Motion (UCM), speed is constant, but velocity changes direction. 
            This requires a centripetal acceleration (<span class="var">a<sub>c</sub></span>) pointing toward the center.
            <br>Vectors: <span style="color:#2ecc71">Green = Velocity</span>, <span style="color:#f1c40f">Yellow = Acceleration</span>.</p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Radius (<i class="var">r</i>): <span id="val-r">100</span> m</label>
                <input type="range" id="in-r" min="50" max="150" value="100" oninput="reset_3_1()">
            </div>
            <div class="control-group">
                <label>Velocity (<i class="var">v</i>): <span id="val-v">5</span> m/s</label>
                <input type="range" id="in-v" min="1" max="10" value="5" oninput="reset_3_1()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_3_1()">Play / Pause</button>
            <div class="readout">Centripetal Accel (<i class="var">a<sub>c</sub></i>): <span id="out-ac">0.0</span> m/s²</div>
        `;
        reset_3_1();
    }

    function reset_3_1() {
        state = { 
            r: parseFloat(document.getElementById('in-r').value), 
            v: parseFloat(document.getElementById('in-v').value),
            angle: 0, running: false 
        };
        // ac = v^2 / r
        let ac = (state.v * state.v) / (state.r / 10); // scale factor fix
        document.getElementById('val-r').innerText = state.r;
        document.getElementById('val-v').innerText = state.v;
        document.getElementById('out-ac').innerText = (state.v**2 / (state.r/10)).toFixed(2);
        draw_3_1();
    }

    function loop_3_1() {
        if(!state.running || currentSim !== '3.1') return;

        // Angular velocity w = v / r
        let w = state.v / state.r; 
        state.angle += w * 5; // speed multiplier for visuals

        draw_3_1();
        animId = requestAnimationFrame(loop_3_1);
    }

    function draw_3_1() {
        ctx.fillStyle = "#000"; ctx.fillRect(0,0,700,450);
        let cx = 350, cy = 225;

        // Path
        ctx.strokeStyle = "#333"; ctx.lineWidth = 2; ctx.beginPath();
        ctx.arc(cx, cy, state.r, 0, Math.PI*2); ctx.stroke();

        // Object
        let ox = cx + state.r * Math.cos(state.angle);
        let oy = cy + state.r * Math.sin(state.angle);

        ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(ox, oy, 8, 0, Math.PI*2); ctx.fill();

        // Vectors
        // Velocity (Tangent)
        let vx = -Math.sin(state.angle) * state.v * 8;
        let vy = Math.cos(state.angle) * state.v * 8;
        drawVector(ox, oy, vx, vy, "#2ecc71"); // Green

        // Acceleration (Radial Inward)
        let ax = -Math.cos(state.angle) * 60;
        let ay = -Math.sin(state.angle) * 60;
        drawVector(ox, oy, ax, ay, "#f1c40f"); // Yellow
    }

    function missing(title) {
        document.getElementById('sim-title').innerText = title;
        document.getElementById('sim-desc').innerHTML = "<p>This simulation is queued for generation in the next update.</p>";
        document.getElementById('sim-controls').innerHTML = "<p style='color:#777; font-style:italic;'>Controls loading...</p>";
        ctx.clearRect(0,0,700,450);
        ctx.fillStyle = "#f4f6f7"; ctx.fillRect(0,0,700,450);
        ctx.fillStyle = "#333"; ctx.font = "20px Arial"; ctx.fillText("Pending Construction...", 250, 225);
    }

    // Helper: Draw Arrow
    function drawVector(x, y, dx, dy, color) {
        let head = 10;
        let angle = Math.atan2(dy, dx);
        ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + dx, y + dy); ctx.stroke();
        ctx.beginPath(); 
        ctx.moveTo(x+dx, y+dy);
        ctx.lineTo(x+dx - head*Math.cos(angle-Math.PI/6), y+dy - head*Math.sin(angle-Math.PI/6));
        ctx.lineTo(x+dx - head*Math.cos(angle+Math.PI/6), y+dy - head*Math.sin(angle+Math.PI/6));
        ctx.fill();
        ctx.lineWidth = 1;
    }

    function drawCar(x, y, v) {
        ctx.fillStyle = "#34495e";
        ctx.fillRect(x-15, y-10, 30, 20); // Body
        ctx.fillStyle = "black";
        ctx.beginPath(); ctx.arc(x-10, y+10, 4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(x+10, y+10, 4, 0, Math.PI*2); ctx.fill();
        // Velocity Arrow
        drawVector(x, y-15, v*3, 0, "red");
    }

    function drawGrid(step) {
        ctx.strokeStyle = "#e0e0e0";
        ctx.beginPath();
        for(let x=0; x<700; x+=step) { ctx.moveTo(x,0); ctx.lineTo(x,450); }
        for(let y=0; y<450; y+=step) { ctx.moveTo(0,y); ctx.lineTo(700,y); }
        ctx.stroke();
    }

    // ===============================================
    // === UNIT 4: ENERGY (Skate Park) ===
    // ===============================================
    function setup_4_1() {
        document.getElementById('sim-title').innerText = "4.1 Conservation of Energy";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Energy Transformation</h3>
            <p>As the skater moves down the ramp, Potential Energy (<span class="var">U<sub>g</sub></span>) converts to Kinetic Energy (<span class="var">K</span>).
            In the absence of friction, the Total Mechanical Energy (<span class="var">E<sub>total</sub></span>) remains constant.</p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Mass (<i class="var">m</i>): <span id="val-m">50</span> kg</label>
                <input type="range" id="in-m" min="10" max="100" value="50" oninput="reset_4_1()">
            </div>
            <div class="control-group">
                <label>Start Height (<i class="var">h</i>): <span id="val-h">5</span> m</label>
                <input type="range" id="in-h" min="1" max="8" value="5" oninput="reset_4_1()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_4_1()">Play / Pause</button>
            <button class="btn btn-red" onclick="reset_4_1()">Reset</button>
        `;
        reset_4_1();
    }

    function reset_4_1() {
        state = { 
            m: parseFloat(document.getElementById('in-m').value), 
            hStart: parseFloat(document.getElementById('in-h').value),
            x: 0, running: false 
        };
        // Map x (0 to 700) to a track shape
        // Track: Parabola y = 0.003(x-350)^2
        document.getElementById('val-m').innerText = state.m;
        document.getElementById('val-h').innerText = state.hStart;

        // Start at left rim corresponding to height
        state.x = 350 - Math.sqrt(state.hStart / 0.003 * 10); // Inverse parabola
        draw_4_1();
    }

    function loop_4_1() {
        if(!state.running || currentSim !== '4.1') return;

        // Physics: Conservation of Energy
        // Total E = mgh_start
        // At any point: K = Total E - U
        // v = sqrt(2K/m)

        let g = 9.8;
        let scale = 40; // 40px = 1m
        let yBase = 400;

        // Track Geometry
        let dx = state.x - 350;
        let h = 0.003 * dx * dx / 10; // Height in meters
        let yPixels = yBase - h * scale;

        let Etot = state.m * g * state.hStart;
        let U = state.m * g * h;
        let K = Etot - U;

        if(K < 0) K = 0; // Floating point error catch
        let v = Math.sqrt(2 * K / state.m);

        // Direction logic
        if (!state.dir) state.dir = 1;

        // Move
        let slope = 0.006 * (state.x - 350); // dy/dx
        let angle = Math.atan(slope);
        let vx = v * Math.cos(angle);

        // Bounds check
        if (h > state.hStart && state.x > 350 && state.dir === 1) state.dir = -1;
        if (h > state.hStart && state.x < 350 && state.dir === -1) state.dir = 1;

        state.x += vx * state.dir * 0.2; // Time step factor

        state.K = K; state.U = U; state.Etot = Etot; // Store for draw
        draw_4_1();
        animId = requestAnimationFrame(loop_4_1);
    }

    function draw_4_1() {
        ctx.clearRect(0,0,700,450);

        // Draw Track
        ctx.beginPath();
        ctx.strokeStyle = "#555"; ctx.lineWidth = 5;
        for(let i=0; i<=700; i+=10) {
            let h = 0.003 * (i-350)**2 / 10;
            let y = 400 - h * 40;
            if(i===0) ctx.moveTo(i,y); else ctx.lineTo(i,y);
        }
        ctx.stroke();

        // Skater
        let h = 0.003 * (state.x-350)**2 / 10;
        let y = 400 - h * 40;
        ctx.fillStyle = "#e67e22"; 
        ctx.beginPath(); ctx.arc(state.x, y-10, 10, 0, Math.PI*2); ctx.fill();

        // --- BAR CHART ---
        // Setup
        let bx = 550, by = 150;
        let maxH = 100;
        let total = (state.Etot) ? state.Etot : state.m * 9.8 * state.hStart; // Fallback if not running

        // K (Green)
        let kH = (state.K / total) * maxH || 0;
        ctx.fillStyle = "#2ecc71"; ctx.fillRect(bx, by - kH, 30, kH);
        ctx.fillStyle = "#333"; ctx.fillText("K", bx+10, by+15);

        // U (Blue)
        let uH = (state.U / total) * maxH || (state.hStart > 0 ? maxH : 0); // Default full if reset
        ctx.fillStyle = "#3498db"; ctx.fillRect(bx+40, by - uH, 30, uH);
        ctx.fillText("U", bx+50, by+15);

        // Total (Yellow)
        ctx.fillStyle = "#f1c40f"; ctx.fillRect(bx+80, by - maxH, 30, maxH);
        ctx.fillText("Etot", bx+80, by+15);
    }

    // ===============================================
    // === UNIT 5: MOMENTUM (Collisions) ===
    // ===============================================
    function setup_5_1() {
        document.getElementById('sim-title').innerText = "5.1 Momentum & Collisions";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Conservation of Momentum</h3>
            <p>Momentum (<span class="var">p = mv</span>) is always conserved in collisions.
            <br><b>Elastic:</b> Objects bounce, Kinetic Energy conserved.
            <br><b>Inelastic:</b> Objects stick, Kinetic Energy lost to heat.</p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Mass 1 (Red): <span id="v-m1">2</span> kg</label>
                <input type="range" id="in-m1" min="1" max="5" value="2" oninput="reset_5_1()">
            </div>
            <div class="control-group">
                <label>Mass 2 (Blue): <span id="v-m2">2</span> kg</label>
                <input type="range" id="in-m2" min="1" max="5" value="2" oninput="reset_5_1()">
            </div>
            <div class="control-group">
                <label>Elasticity: <span id="v-e">Elastic (1.0)</span></label>
                <input type="range" id="in-e" min="0" max="1" step="1" value="1" oninput="reset_5_1()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_5_1()">Collide</button>
            <button class="btn btn-red" onclick="reset_5_1()">Reset</button>
        `;
        reset_5_1();
    }

    function reset_5_1() {
        state = {
            m1: parseFloat(document.getElementById('in-m1').value),
            m2: parseFloat(document.getElementById('in-m2').value),
            e: parseFloat(document.getElementById('in-e').value), // 1 = elastic, 0 = inelastic
            x1: 100, v1: 5,
            x2: 500, v2: -2,
            running: false
        };

        document.getElementById('v-m1').innerText = state.m1;
        document.getElementById('v-m2').innerText = state.m2;
        document.getElementById('v-e').innerText = state.e === 1 ? "Elastic (Bouncy)" : "Inelastic (Sticky)";

        draw_5_1();
    }

    function loop_5_1() {
        if(!state.running || currentSim !== '5.1') return;

        state.x1 += state.v1;
        state.x2 += state.v2;

        // Collision Detect
        let s1 = state.m1 * 15; // Size proportional to mass
        let s2 = state.m2 * 15;

        if (state.x1 + s1 >= state.x2) {
            // Physics 1D Collision Eq
            let v1i = state.v1;
            let v2i = state.v2;
            let m1 = state.m1;
            let m2 = state.m2;

            if (state.e === 0) {
                // Perfectly Inelastic (Stick)
                let vf = (m1*v1i + m2*v2i) / (m1 + m2);
                state.v1 = vf; 
                state.v2 = vf;
            } else {
                // Elastic
                state.v1 = ((m1-m2)*v1i + 2*m2*v2i) / (m1+m2);
                state.v2 = ((m2-m1)*v2i + 2*m1*v1i) / (m1+m2);
            }

            // Separate slightly to prevent sticky-bug
            state.x1 = state.x2 - s1 - 1; 
        }

        draw_5_1();
        animId = requestAnimationFrame(loop_5_1);
    }

    function draw_5_1() {
        ctx.clearRect(0,0,700,450);
        // Track
        ctx.fillStyle = "#ddd"; ctx.fillRect(0, 200, 700, 10);

        let s1 = state.m1 * 15;
        let s2 = state.m2 * 15;

        // Cart 1
        ctx.fillStyle = "#e74c3c"; ctx.fillRect(state.x1, 200 - s1, s1, s1);
        ctx.fillStyle = "white"; ctx.fillText(state.v1.toFixed(1) + " m/s", state.x1, 190 - s1);

        // Cart 2
        ctx.fillStyle = "#3498db"; ctx.fillRect(state.x2, 200 - s2, s2, s2);
        ctx.fillStyle = "black"; ctx.fillText(state.v2.toFixed(1) + " m/s", state.x2, 190 - s2);
    }

    // ===============================================
    // === UNIT 6: SHM (Springs) ===
    // ===============================================
    function setup_6_1() {
        document.getElementById('sim-title').innerText = "6.1 Simple Harmonic Motion";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Hooke's Law</h3>
            <p>Restoring Force: <span class="var">F<sub>s</sub> = -kx</span>.
            <br>Period: <span class="var">T = 2&pi;&radic;(m/k)</span>.
            <br>Observe the graph of Position vs. Time.</p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Mass (<i class="var">m</i>): <span id="v-m">1</span> kg</label>
                <input type="range" id="in-m" min="0.5" max="3" step="0.5" value="1" oninput="reset_6_1()">
            </div>
            <div class="control-group">
                <label>Spring Constant (<i class="var">k</i>): <span id="v-k">10</span> N/m</label>
                <input type="range" id="in-k" min="5" max="30" value="10" oninput="reset_6_1()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_6_1()">Play / Pause</button>
            <button class="btn btn-red" onclick="reset_6_1()">Reset</button>
            <div class="readout">Period (<i class="var">T</i>): <span id="out-t">0.0</span>s</div>
        `;
        reset_6_1();
    }

    function reset_6_1() {
        state = {
            m: parseFloat(document.getElementById('in-m').value),
            k: parseFloat(document.getElementById('in-k').value),
            t: 0, 
            amp: 100, // Pixels
            graph: [],
            running: false
        };
        document.getElementById('v-m').innerText = state.m;
        document.getElementById('v-k').innerText = state.k;
        let T = 2 * Math.PI * Math.sqrt(state.m / state.k);
        document.getElementById('out-t').innerText = T.toFixed(2);
        draw_6_1();
    }

    function loop_6_1() {
        if(!state.running || currentSim !== '6.1') return;
        state.t += 0.05;
        let w = Math.sqrt(state.k / state.m);
        let x = state.amp * Math.cos(w * state.t);

        state.x = x;
        state.graph.push(x);
        if(state.graph.length > 300) state.graph.shift();

        draw_6_1();
        animId = requestAnimationFrame(loop_6_1);
    }

    function draw_6_1() {
        ctx.clearRect(0,0,700,450);

        let wallX = 50;
        let eqX = 350;
        let blockX = eqX + (state.running ? state.x : state.amp);

        // Wall
        ctx.fillStyle = "#7f8c8d"; ctx.fillRect(wallX, 100, 20, 100);

        // Floor
        ctx.beginPath(); ctx.moveTo(wallX, 200); ctx.lineTo(700, 200); ctx.stroke();

        // Spring
        ctx.beginPath(); ctx.strokeStyle = "#333";
        let coils = 20;
        let springW = blockX - (wallX + 20);
        let coilW = springW / coils;
        ctx.moveTo(wallX+20, 150);
        for(let i=0; i<coils; i++) {
            ctx.lineTo(wallX+20 + coilW*(i+0.5), 150 + (i%2==0 ? 10 : -10));
        }
        ctx.lineTo(blockX, 150);
        ctx.stroke();

        // Block
        ctx.fillStyle = "#3498db"; ctx.fillRect(blockX, 130, 40, 40);

        // Equilibrium Line
        ctx.strokeStyle = "green"; ctx.setLineDash([5,5]);
        ctx.beginPath(); ctx.moveTo(eqX+20, 100); ctx.lineTo(eqX+20, 250); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = "green"; ctx.fillText("x=0", eqX+10, 265);

        // Graph Overlay
        ctx.fillStyle = "#fafafa"; ctx.fillRect(50, 300, 600, 120);
        ctx.strokeStyle = "#bdc3c7"; ctx.strokeRect(50, 300, 600, 120);

        ctx.beginPath(); ctx.strokeStyle = "red";
        state.graph.forEach((val, i) => {
            let gx = 650 - (state.graph.length - i) * 2;
            let gy = 360 - (val / 100) * 50; // Scale
            if(i==0) ctx.moveTo(gx, gy); else ctx.lineTo(gx, gy);
        });
        ctx.stroke();
        ctx.fillStyle = "#333"; ctx.fillText("Position vs Time", 60, 320);
    }

    // ===============================================
    // === UNIT 7: TORQUE (Seesaw) ===
    // ===============================================
    function setup_7_1() {
        document.getElementById('sim-title').innerText = "7.1 Torque & Equilibrium";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Rotational Equilibrium</h3>
            <p>Torque (<span class="var">&tau; = rFsin&theta;</span>) causes rotation. 
            For the beam to balance, the net torque must be zero. 
            <br><span class="var">&tau;<sub>net</sub> = &tau;<sub>ccw</sub> - &tau;<sub>cw</sub> = 0</span></p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Mass 1 (Left): <span id="v-m1">10</span> kg</label>
                <input type="range" id="in-m1" min="5" max="20" value="10" oninput="update_7_1()">
            </div>
            <div class="control-group">
                <label>Position 1 (<i class="var">r<sub>1</sub></i>): <span id="v-r1">2.0</span> m</label>
                <input type="range" id="in-r1" min="0.5" max="3.0" step="0.5" value="2.0" oninput="update_7_1()">
            </div>
            <div class="control-group">
                <label>Mass 2 (Right): <span id="v-m2">10</span> kg</label>
                <input type="range" id="in-m2" min="5" max="20" value="10" oninput="update_7_1()">
            </div>
            <div class="control-group">
                <label>Position 2 (<i class="var">r<sub>2</sub></i>): <span id="v-r2">2.0</span> m</label>
                <input type="range" id="in-r2" min="0.5" max="3.0" step="0.5" value="2.0" oninput="update_7_1()">
            </div>
            <div class="readout">Net Torque: <span id="out-tau">0.0</span> N&middot;m</div>
        `;
        update_7_1();
    }

    function update_7_1() {
        state = {
            m1: parseFloat(document.getElementById('in-m1').value),
            r1: parseFloat(document.getElementById('in-r1').value),
            m2: parseFloat(document.getElementById('in-m2').value),
            r2: parseFloat(document.getElementById('in-r2').value),
        };
        document.getElementById('v-m1').innerText = state.m1;
        document.getElementById('v-r1').innerText = state.r1;
        document.getElementById('v-m2').innerText = state.m2;
        document.getElementById('v-r2').innerText = state.r2;

        let tau1 = state.m1 * 9.8 * state.r1; // CCW (+)
        let tau2 = state.m2 * 9.8 * state.r2; // CW (-)
        state.net = tau1 - tau2;

        document.getElementById('out-tau').innerText = state.net.toFixed(1);

        // Calculate Tilt
        state.angle = 0;
        if (Math.abs(state.net) > 5) {
            state.angle = state.net > 0 ? -20 : 20; // Tilt left or right
        }
        draw_7_1();
    }

    function draw_7_1() {
        ctx.clearRect(0,0,700,450);

        let cx = 350, cy = 300;

        // Fulcrum
        ctx.fillStyle = "#7f8c8d";
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx-20, cy+40); ctx.lineTo(cx+20, cy+40); ctx.fill();

        // Beam Rotation
        ctx.save();
        ctx.translate(cx, cy);
        let rad = state.angle * Math.PI / 180;
        ctx.rotate(rad);

        // Beam
        ctx.fillStyle = "#8e44ad"; ctx.fillRect(-250, -5, 500, 10);

        // Mass 1 (Left)
        let x1 = -state.r1 * 80; // Scale
        let s1 = state.m1 * 3;
        ctx.fillStyle = "#e74c3c"; ctx.fillRect(x1 - s1/2, -5 - s1, s1, s1);
        ctx.fillStyle = "white"; ctx.fillText(state.m1, x1-5, -10);

        // Mass 2 (Right)
        let x2 = state.r2 * 80;
        let s2 = state.m2 * 3;
        ctx.fillStyle = "#3498db"; ctx.fillRect(x2 - s2/2, -5 - s2, s2, s2);
        ctx.fillStyle = "white"; ctx.fillText(state.m2, x2-5, -10);

        ctx.restore();
    }
// ===============================================
    // === UNIT 5.1: IMPULSE (New) ===
    // ===============================================
    function setup_5_1() {
        document.getElementById('sim-title').innerText = "5.1 Momentum and Impulse";
        document.getElementById('sim-desc').innerHTML = `
            <h3>The Impulse-Momentum Theorem</h3>
            <p>Impulse (<span class="var">J</span>) is the change in momentum. It is equal to the average Force multiplied by the time interval.
            <br>Eq: <span class="var">J = F&Delta;t = &Delta;p = m&Delta;v</span>.
            <br>Observe how a longer impact time reduces the force required to stop an object (like an airbag).</p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Mass (<i class="var">m</i>): <span id="v-m">2</span> kg</label>
                <input type="range" id="in-m" min="1" max="10" value="2" oninput="reset_5_1()">
            </div>
            <div class="control-group">
                <label>Initial Velocity (<i class="var">v<sub>i</sub></i>): <span id="v-vi">10</span> m/s</label>
                <input type="range" id="in-vi" min="5" max="20" value="10" oninput="reset_5_1()">
            </div>
            <div class="control-group">
                <label>Impact Duration (<i class="var">&Delta;t</i>): <span id="v-dt">1.0</span> s</label>
                <input type="range" id="in-dt" min="0.1" max="2.0" step="0.1" value="1.0" oninput="reset_5_1()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_5_1()">Crash!</button>
            <button class="btn btn-red" onclick="reset_5_1()">Reset</button>
            <div class="readout">Avg Force (<i class="var">F<sub>avg</sub></i>): <span id="out-f">0.0</span> N</div>
        `;
        reset_5_1();
    }

    function reset_5_1() {
        state = {
            m: parseFloat(document.getElementById('in-m').value),
            vi: parseFloat(document.getElementById('in-vi').value),
            dt: parseFloat(document.getElementById('in-dt').value),
            x: 0, v: 0, t: 0, running: false, crashed: false
        };
        state.v = state.vi;
        document.getElementById('v-m').innerText = state.m;
        document.getElementById('v-vi').innerText = state.vi;
        document.getElementById('v-dt').innerText = state.dt;
        document.getElementById('out-f').innerText = "0.0";
        draw_5_1();
    }

    function loop_5_1() {
        if(!state.running || currentSim !== '5.1') return;

        // Simulating the crash phase
        if (state.x < 500) {
            state.x += state.v * 0.05; // Normal movement
        } else if (!state.crashed) {
            state.crashed = true;
            state.crashStart = state.t;
        }

        // Deceleration Phase (Impulse)
        if (state.crashed) {
             let progress = state.t - state.crashStart;
             if (progress < state.dt) {
                 // v = vi - (a * t)
                 // a = vi / dt
                 let a = state.vi / state.dt;
                 state.v = state.vi - (a * progress);
                 if(state.v < 0) state.v = 0;
                 state.x += state.v * 0.05;

                 // Show Force
                 let F = (state.m * state.vi) / state.dt; // F = dp/dt
                 document.getElementById('out-f').innerText = F.toFixed(1);
             } else {
                 state.v = 0;
                 state.running = false;
             }
        }

        state.t += 0.05;
        draw_5_1();
        animId = requestAnimationFrame(loop_5_1);
    }

    function draw_5_1() {
        ctx.clearRect(0,0,700,450);

        // Wall
        ctx.fillStyle = "#7f8c8d"; ctx.fillRect(550, 100, 50, 200);
        // Crumple Zone visualization
        if(state.crashed && state.x > 500) {
             ctx.fillStyle = "#e74c3c"; // Red impact
             ctx.globalAlpha = 0.5;
             ctx.fillRect(550, 100, 10, 200);
             ctx.globalAlpha = 1.0;
        }

        // Cart
        let w = 50;
        // Crumple effect: make cart shorter as it impacts
        if (state.x > 500) w = 50 - (state.x - 500);
        if (w < 10) w = 10;

        ctx.fillStyle = "#2980b9"; ctx.fillRect(state.x, 225, w, 40);
        ctx.fillStyle = "white"; ctx.fillText(state.m+"kg", state.x+5, 250);

        // Floor
        ctx.beginPath(); ctx.moveTo(0, 265); ctx.lineTo(600, 265); ctx.stroke();
    }

    // ===============================================
    // === UNIT 5.2: CONSERVATION (Renamed Old 5.1) ===
    // ===============================================
    function setup_5_2() {
        // ... Calls the previous setup_5_1 logic ...
        setup_5_1_OLD(); 
        document.getElementById('sim-title').innerText = "5.2 Conservation of Momentum";
    }
    // Rename your old setup_5_1 function to setup_5_1_OLD in your code, or just copy the logic here.
    // For simplicity in this paste, I will re-declare the logic for 5.2 here:
    function setup_5_2() {
        document.getElementById('sim-title').innerText = "5.2 Conservation of Momentum";
        document.getElementById('sim-desc').innerHTML = `<h3>Elastic vs Inelastic Collisions</h3><p>Momentum is conserved in all collisions. Kinetic energy is only conserved in elastic collisions.</p>`;
        // Re-use controls from previous 5.1 response...
        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group"><label>Mass 1: <span id="v-m1">2</span>kg</label><input type="range" id="in-m1" min="1" max="5" value="2" oninput="reset_5_2()"></div>
            <div class="control-group"><label>Mass 2: <span id="v-m2">2</span>kg</label><input type="range" id="in-m2" min="1" max="5" value="2" oninput="reset_5_2()"></div>
            <div class="control-group"><label>Elasticity: <span id="v-e">1</span></label><input type="range" id="in-e" min="0" max="1" step="1" value="1" oninput="reset_5_2()"></div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_5_2()">Collide</button>
            <button class="btn btn-red" onclick="reset_5_2()">Reset</button>
        `;
        reset_5_2();
    }
    function reset_5_2() {
        state = { m1: parseFloat(document.getElementById('in-m1').value), m2: parseFloat(document.getElementById('in-m2').value), e: parseFloat(document.getElementById('in-e').value), x1: 100, v1: 5, x2: 500, v2: -2, running: false };
        document.getElementById('v-m1').innerText = state.m1; document.getElementById('v-m2').innerText = state.m2; document.getElementById('v-e').innerText = state.e;
        draw_5_2();
    }
    function loop_5_2() {
        if(!state.running || currentSim !== '5.2') return;
        state.x1 += state.v1; state.x2 += state.v2;
        let s1 = state.m1*15; let s2 = state.m2*15;
        if(state.x1 + s1 >= state.x2) {
             let v1i = state.v1; let v2i = state.v2; let m1 = state.m1; let m2 = state.m2;
             if(state.e === 0) { let vf = (m1*v1i + m2*v2i)/(m1+m2); state.v1 = vf; state.v2 = vf; }
             else { state.v1 = ((m1-m2)*v1i + 2*m2*v2i)/(m1+m2); state.v2 = ((m2-m1)*v2i + 2*m1*v1i)/(m1+m2); }
             state.x1 = state.x2 - s1 - 1;
        }
        draw_5_2(); animId = requestAnimationFrame(loop_5_2);
    }
    function draw_5_2() {
        ctx.clearRect(0,0,700,450); ctx.fillStyle = "#ddd"; ctx.fillRect(0,200,700,10);
        let s1 = state.m1*15; let s2 = state.m2*15;
        ctx.fillStyle = "#e74c3c"; ctx.fillRect(state.x1, 200-s1, s1, s1); ctx.fillText(state.v1.toFixed(1), state.x1, 190-s1);
        ctx.fillStyle = "#3498db"; ctx.fillRect(state.x2, 200-s2, s2, s2); ctx.fillText(state.v2.toFixed(1), state.x2, 190-s2);
    }


    // ===============================================
    // === UNIT 7.2: ANGULAR MOMENTUM (New) ===
    // ===============================================
    function setup_7_2() {
        document.getElementById('sim-title').innerText = "7.2 Rotational Inertia & Angular Momentum";
        document.getElementById('sim-desc').innerHTML = `
            <h3>The "Figure Skater" Effect</h3>
            <p>Angular Momentum (<span class="var">L = I&omega;</span>) is conserved. 
            If you pull mass inward, Rotational Inertia (<span class="var">I</span>) decreases, causing Angular Velocity (<span class="var">&omega;</span>) to increase.
            <br><i>Sim: Change the radius of the rotating masses.</i></p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Radius of Mass (<i class="var">r</i>): <span id="v-r">1.0</span> m</label>
                <input type="range" id="in-r" min="0.2" max="2.0" step="0.1" value="1.0" oninput="update_7_2()">
            </div>
            <div class="readout">Inertia (<i class="var">I</i>): <span id="out-I">0.0</span> kg&middot;m²</div>
            <div class="readout">Ang. Vel (<i class="var">&omega;</i>): <span id="out-w">0.0</span> rad/s</div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_7_2()">Spin</button>
        `;

        // Initial State: L is constant (set L = 10)
        state = { 
            L: 10, 
            m: 2, // 2kg masses
            r: 1.0, 
            angle: 0, 
            running: false 
        };
        update_7_2();
    }

    function update_7_2() {
        if(currentSim !== '7.2') return;
        state.r = parseFloat(document.getElementById('in-r').value);

        // I = mr^2 (for point masses) * 2 masses
        state.I = 2 * state.m * state.r * state.r;

        // L = Iw  =>  w = L / I
        state.w = state.L / state.I;

        document.getElementById('v-r').innerText = state.r.toFixed(1);
        document.getElementById('out-I').innerText = state.I.toFixed(2);
        document.getElementById('out-w').innerText = state.w.toFixed(2);
        draw_7_2();
    }

    function loop_7_2() {
        if(!state.running || currentSim !== '7.2') return;
        state.angle += state.w * 0.05;
        draw_7_2();
        animId = requestAnimationFrame(loop_7_2);
    }

    function draw_7_2() {
        ctx.clearRect(0,0,700,450);
        let cx = 350, cy = 225;

        // Center Pivot
        ctx.fillStyle = "#333"; ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.fill();

        // Arms
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(state.angle);

        // Draw Rod
        let armLen = state.r * 100; // Scale
        ctx.strokeStyle = "#7f8c8d"; ctx.lineWidth = 5;
        ctx.beginPath(); ctx.moveTo(-armLen, 0); ctx.lineTo(armLen, 0); ctx.stroke();

        // Draw Masses
        ctx.fillStyle = "#e67e22";
        ctx.beginPath(); ctx.arc(-armLen, 0, 15, 0, Math.PI*2); ctx.fill(); // Left
        ctx.beginPath(); ctx.arc(armLen, 0, 15, 0, Math.PI*2); ctx.fill(); // Right

        ctx.restore();

        // Speed lines if fast
        if(state.w > 5) {
            ctx.strokeStyle = "rgba(0,0,0,0.1)"; ctx.lineWidth=2;
            ctx.beginPath(); ctx.arc(cx, cy, armLen, 0, Math.PI*2); ctx.stroke();
        }
    }
    // ===============================================
    // === UNIT 1.4: RELATIVE MOTION (River Boat) ===
    // ===============================================
    function setup_1_4() {
        document.getElementById('sim-title').innerText = "1.4 Relative Motion (Reference Frames)";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Adding Velocity Vectors</h3>
            <p>A boat moves relative to the water, while the water moves relative to the ground.
            <br>The Resultant Velocity (<span class="var">v<sub>total</sub></span>) is the vector sum: <span class="var">v<sub>boat</sub> + v<sub>river</sub></span>.
            <br><i>Challenge: Can you aim the boat to land directly across?</i></p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Boat Speed (<i class="var">v<sub>b</sub></i>): <span id="v-vb">5</span> m/s</label>
                <input type="range" id="in-vb" min="1" max="10" value="5" oninput="reset_1_4()">
            </div>
            <div class="control-group">
                <label>River Speed (<i class="var">v<sub>r</sub></i>): <span id="v-vr">3</span> m/s</label>
                <input type="range" id="in-vr" min="0" max="8" value="3" oninput="reset_1_4()">
            </div>
            <div class="control-group">
                <label>Heading Angle (<i class="var">&theta;</i>): <span id="v-ang">90</span>&deg;</label>
                <input type="range" id="in-ang" min="45" max="135" value="90" oninput="reset_1_4()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_1_4()">Launch</button>
            <button class="btn btn-red" onclick="reset_1_4()">Reset</button>
        `;
        reset_1_4();
    }

    function reset_1_4() {
        state = {
            vb: parseFloat(document.getElementById('in-vb').value),
            vr: parseFloat(document.getElementById('in-vr').value),
            ang: parseFloat(document.getElementById('in-ang').value),
            x: 350, // Start middle bottom
            y: 400,
            path: [],
            running: false
        };
        // Angle 90 is straight UP. 0 is Right.
        // Convert Heading (degrees) to Radians.
        // Input: 90 is straight up. Canvas: -PI/2 is straight up. 
        // Let's use math angle: 90 deg = PI/2.

        document.getElementById('v-vb').innerText = state.vb;
        document.getElementById('v-vr').innerText = state.vr;
        document.getElementById('v-ang').innerText = state.ang;

        state.path.push({x: state.x, y: state.y});
        draw_1_4();
    }

    function loop_1_4() {
        if(!state.running || currentSim !== '1.4') return;

        let dt = 0.05;
        let rad = state.ang * Math.PI / 180; // Input angle (90 is up)

        // Boat Velocity Components (Relative to Water)
        // Cos(90) = 0. Sin(90) = 1.
        let vbx = state.vb * Math.cos(rad); 
        let vby = -state.vb * Math.sin(rad); // Negative because Up is -Y

        // River Velocity (Relative to Ground)
        let vrx = state.vr; // Flowing Right
        let vry = 0;

        // Total Velocity
        let vtx = vbx + vrx;
        let vty = vby + vry;

        state.x += vtx * 5 * dt; // Scale factor 5
        state.y += vty * 5 * dt;

        state.path.push({x: state.x, y: state.y});

        // Stop at other bank (Y=50) or off screen
        if (state.y < 50 || state.x > 700 || state.x < 0) state.running = false;

        draw_1_4();
        animId = requestAnimationFrame(loop_1_4);
    }

    function draw_1_4() {
        ctx.clearRect(0,0,700,450);

        // River Water
        ctx.fillStyle = "#3498db"; ctx.fillRect(0, 50, 700, 350);

        // Banks
        ctx.fillStyle = "#27ae60"; 
        ctx.fillRect(0, 0, 700, 50); // Top Bank
        ctx.fillRect(0, 400, 700, 50); // Bottom Bank

        // Path
        ctx.strokeStyle = "white"; ctx.setLineDash([5,5]); ctx.beginPath();
        state.path.forEach((p,i) => {
            if(i==0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
        });
        ctx.stroke(); ctx.setLineDash([]);

        // Boat
        ctx.save();
        ctx.translate(state.x, state.y);
        // Rotate to match HEADING (not actual path)
        ctx.rotate( - (state.ang * Math.PI/180) + Math.PI/2 ); // Adjust for canvas

        ctx.fillStyle = "#e67e22";
        ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(10, 10); ctx.lineTo(-10, 10); ctx.fill();
        ctx.restore();

        // Vectors (drawn at boat)
        if(state.running || state.y > 350) {
            // Boat Vector (Red)
            let rad = state.ang * Math.PI / 180;
            drawVector(state.x, state.y, 40*Math.cos(rad), -40*Math.sin(rad), "red");

            // River Vector (Blue)
            drawVector(state.x, state.y, state.vr*10, 0, "blue");

            // Resultant (Green) - Only show if moving or specifically desired
             let vbx = state.vb * Math.cos(rad); 
             let vrx = state.vr;
             let vby = state.vb * Math.sin(rad); // Magnitude up

             // Resultant X = vbx + vrx, Y = vby
             // drawVector(state.x, state.y, (vbx+vrx)*5, -vby*5, "#f1c40f");
        }
    }


    // ===============================================
    // === UNIT 6.2: THE PENDULUM ===
    // ===============================================
    function setup_6_2() {
        document.getElementById('sim-title').innerText = "6.2 The Simple Pendulum";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Period of a Pendulum</h3>
            <p>The Period (<span class="var">T</span>) depends on length (<span class="var">L</span>) and gravity (<span class="var">g</span>), but NOT mass.
            <br>Eq: <span class="var">T = 2&pi;&radic;(L/g)</span>.
            <br><i>Experiment: Change the mass and see if the period changes!</i></p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Length (<i class="var">L</i>): <span id="v-len">1.0</span> m</label>
                <input type="range" id="in-len" min="0.5" max="2.5" step="0.1" value="1.0" oninput="reset_6_2()">
            </div>
            <div class="control-group">
                <label>Mass (<i class="var">m</i>): <span id="v-m">1.0</span> kg</label>
                <input type="range" id="in-m" min="0.1" max="5.0" step="0.1" value="1.0" oninput="reset_6_2()">
            </div>
            <div class="control-group">
                <label>Gravity (<i class="var">g</i>): <span id="v-g">9.8</span> m/s²</label>
                <input type="range" id="in-g" min="1.6" max="20" step="0.1" value="9.8" oninput="reset_6_2()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_6_2()">Swing</button>
            <div class="readout">Period (<i class="var">T</i>): <span id="out-t">0.00</span> s</div>
        `;
        reset_6_2();
    }

    function reset_6_2() {
        state = {
            L: parseFloat(document.getElementById('in-len').value),
            m: parseFloat(document.getElementById('in-m').value),
            g: parseFloat(document.getElementById('in-g').value),
            theta: Math.PI / 6, // Start at 30 degrees
            omega: 0,
            t: 0,
            running: false
        };

        let T = 2 * Math.PI * Math.sqrt(state.L / state.g);

        document.getElementById('v-len').innerText = state.L;
        document.getElementById('v-m').innerText = state.m;
        document.getElementById('v-g').innerText = state.g;
        document.getElementById('out-t').innerText = T.toFixed(2);

        draw_6_2();
    }

    function loop_6_2() {
        if(!state.running || currentSim !== '6.2') return;

        // Physics (Simple Harmonic Approx for small angles)
        // alpha = -(g/L) * sin(theta)
        let alpha = -(state.g / state.L) * Math.sin(state.theta);
        let dt = 0.03;

        state.omega += alpha * dt;
        state.theta += state.omega * dt;

        // Dampening (Air resistance)
        state.omega *= 0.999; 

        draw_6_2();
        animId = requestAnimationFrame(loop_6_2);
    }

    function draw_6_2() {
        ctx.clearRect(0,0,700,450);

        let cx = 350;
        let cy = 50;
        let scale = 150; // 150px = 1m

        let bobX = cx + (state.L * scale) * Math.sin(state.theta);
        let bobY = cy + (state.L * scale) * Math.cos(state.theta);

        // Ceiling
        ctx.fillStyle = "#7f8c8d"; ctx.fillRect(250, 40, 200, 10);

        // String
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(bobX, bobY);
        ctx.strokeStyle = "#333"; ctx.lineWidth = 2; ctx.stroke();

        // Bob (Size depends on Mass)
        let r = 10 + state.m * 5;
        ctx.beginPath(); ctx.arc(bobX, bobY, r, 0, Math.PI*2);
        ctx.fillStyle = "#8e44ad"; ctx.fill();
        ctx.strokeStyle = "#333"; ctx.lineWidth=1; ctx.stroke();

        // Vertical Reference (Ghost)
        ctx.setLineDash([5,5]); ctx.strokeStyle="#ccc";
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, 400); ctx.stroke();
        ctx.setLineDash([]);
    }
    // ===============================================
    // === UNIT 1.5: GRAPH MATCHING GAME ===
    // ===============================================
    function setup_1_5() {
        document.getElementById('sim-title').innerText = "1.5 Graph Matching Challenge";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Match the Slope!</h3>
            <p>The slope of a Position vs. Time graph represents <b>Velocity</b>.
            <br>Try to adjust the velocity slider in real-time to match the <span style="color:#95a5a6; font-weight:bold;">Gray Target Line</span> with your <span style="color:#e74c3c; font-weight:bold;">Red Line</span>.
            <br><i>Tip: If the gray line goes down, you need negative velocity!</i></p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Velocity (<i class="var">v</i>): <span id="v-val">0</span> m/s</label>
                <input type="range" id="in-v" min="-10" max="10" value="0" step="1" oninput="state.v=parseFloat(this.value); document.getElementById('v-val').innerText=state.v;">
            </div>
            <button class="btn btn-green" onclick="start_1_5()">Start Challenge</button>
            <button class="btn btn-red" onclick="reset_1_5()">Reset / New Graph</button>
            <div class="readout" id="score-disp" style="font-size: 1.2rem; text-align:center;">Score: 0%</div>
        `;
        reset_1_5();
    }

    function reset_1_5() {
        state = { x: 0, v: 0, t: 0, running: false, playerPath: [], targetPath: [] };
        document.getElementById('in-v').value = 0; 
        document.getElementById('v-val').innerText = "0";
        document.getElementById('score-disp').innerText = "Score: 0%";

        // Generate Random Target Path (3 segments)
        // Segment 1: 0-3s
        let t = 0; let x = 0;
        let segs = [
            {dur: 3, v: Math.floor(Math.random()*8)},      // Positive start
            {dur: 3, v: Math.floor(Math.random()*10)-5},   // Mixed
            {dur: 3, v: -Math.floor(Math.random()*8)}      // Negative end
        ];

        segs.forEach(seg => {
            for(let i=0; i<seg.dur*20; i++) { // 20 steps per sec
                x += seg.v * 0.05;
                t += 0.05;
                state.targetPath.push({t:t, x:x});
            }
        });
        draw_1_5();
    }

    function start_1_5() {
        if(state.running) return;
        state.x = 0; state.t = 0; state.v = 0; state.playerPath = [];
        state.running = true;
        document.getElementById('in-v').value = 0; // Reset slider to 0 at start
        loop_1_5();
    }

    function loop_1_5() {
        if(!state.running || currentSim !== '1.5') return;

        state.t += 0.05;
        state.x += state.v * 0.05;
        state.playerPath.push({t: state.t, x: state.x});

        // End condition
        if(state.t >= 9.0) { // 9 seconds total
            state.running = false;
            calcScore_1_5();
        } else {
            draw_1_5();
            animId = requestAnimationFrame(loop_1_5);
        }
    }

    function calcScore_1_5() {
        let error = 0;
        let count = 0;
        for(let i=0; i<state.playerPath.length; i++) {
            if(i < state.targetPath.length) {
                let diff = Math.abs(state.playerPath[i].x - state.targetPath[i].x);
                error += diff;
                count++;
            }
        }
        // Normalize score: 0 error = 100%. avg error of 5m = 0%.
        let avgError = error / count;
        let score = Math.max(0, 100 - (avgError * 10));
        document.getElementById('score-disp').innerText = "Final Score: " + score.toFixed(1) + "%";
    }

    function draw_1_5() {
        ctx.clearRect(0,0,700,450);

        // Draw Axes
        ctx.strokeStyle = "#333"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(50, 225); ctx.lineTo(650, 225); ctx.stroke(); // t-axis
        ctx.beginPath(); ctx.moveTo(50, 50); ctx.lineTo(50, 400); ctx.stroke(); // x-axis
        ctx.fillText("Time (t)", 600, 240); ctx.fillText("Position (x)", 20, 50);

        // Draw Target Path (Gray)
        ctx.strokeStyle = "#95a5a6"; ctx.lineWidth = 8; ctx.lineCap = "round"; ctx.beginPath();
        state.targetPath.forEach((p, i) => {
            let px = 50 + p.t * 60; // Scale time
            let py = 225 - p.x * 5; // Scale position
            if(i==0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        });
        ctx.stroke();

        // Draw Player Path (Red)
        ctx.strokeStyle = "#e74c3c"; ctx.lineWidth = 3; ctx.beginPath();
        state.playerPath.forEach((p, i) => {
            let px = 50 + p.t * 60; 
            let py = 225 - p.x * 5;
            if(i==0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        });
        ctx.stroke();

        // Current Marker
        let cx = 50 + state.t * 60;
        let cy = 225 - state.x * 5;

        // Car Icon
        ctx.fillStyle = "#e74c3c"; ctx.fillRect(cx-10, cy-5, 20, 10);
    }


    // ===============================================
    // === UNIT 7.3: ROTATIONAL KINEMATICS ===
    // ===============================================
    function setup_7_3() {
        document.getElementById('sim-title').innerText = "7.3 Rotational Kinematics";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Linear vs. Angular</h3>
            <p>Angular variables are analogous to linear ones:
            <br>Disp: <span class="var">x</span> (m) &rarr; <span class="var">&theta;</span> (rad)
            <br>Vel: <span class="var">v</span> (m/s) &rarr; <span class="var">&omega;</span> (rad/s)
            <br>Acc: <span class="var">a</span> (m/s²) &rarr; <span class="var">&alpha;</span> (rad/s²)
            <br><i>Watch the "Ladybug" on the rim to see linear velocity (<span class="var">v = r&omega;</span>).</i></p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Ang. Accel (<i class="var">&alpha;</i>): <span id="v-alpha">0.5</span> rad/s²</label>
                <input type="range" id="in-alpha" min="-2" max="2" step="0.1" value="0.5" oninput="reset_7_3()">
            </div>
            <div class="readout">
                Time: <span id="out-t">0.0</span> s<br>
                Ang Vel (<i class="var">&omega;</i>): <span id="out-w">0.0</span> rad/s<br>
                Angle (<i class="var">&theta;</i>): <span id="out-th">0.0</span> rad
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_7_3()">Spin</button>
            <button class="btn btn-red" onclick="reset_7_3()">Reset</button>
        `;
        reset_7_3();
    }

    function reset_7_3() {
        state = {
            alpha: parseFloat(document.getElementById('in-alpha').value),
            w: 0, theta: 0, t: 0, running: false
        };
        document.getElementById('v-alpha').innerText = state.alpha;
        updateReadout_7_3();
        draw_7_3();
    }

    function loop_7_3() {
        if(!state.running || currentSim !== '7.3') return;

        let dt = 0.05;
        state.t += dt;

        // Kinematics: w = w0 + at
        state.w += state.alpha * dt;
        state.theta += state.w * dt;

        updateReadout_7_3();
        draw_7_3();
        animId = requestAnimationFrame(loop_7_3);
    }

    function updateReadout_7_3() {
        document.getElementById('out-t').innerText = state.t.toFixed(1);
        document.getElementById('out-w').innerText = state.w.toFixed(2);
        document.getElementById('out-th').innerText = (state.theta % (2*Math.PI)).toFixed(2);
    }

    function draw_7_3() {
        ctx.clearRect(0,0,700,450);

        let cx = 350, cy = 225;
        let r = 120;

        // Draw Disk
        ctx.fillStyle = "#ecf0f1"; 
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#bdc3c7"; ctx.lineWidth = 3; ctx.stroke();

        // Draw Reference Line (Radius)
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(state.theta);

        // Radius Line
        ctx.strokeStyle = "#7f8c8d"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(r, 0); ctx.stroke();

        // Ladybug at the edge
        ctx.fillStyle = "#e74c3c"; ctx.beginPath(); ctx.arc(r, 0, 12, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(r, -4, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(r, 4, 3, 0, Math.PI*2); ctx.fill();

        // Linear Velocity Vector (Tangent)
        // v = rw
        // In local rotated space, tangent is vertical (perp to radius)
        if(Math.abs(state.w) > 0.1) {
            let vLen = state.w * 20;
            drawVector(r, 0, 0, vLen, "#2ecc71"); // Green Tangent
            ctx.fillStyle = "#2ecc71"; 
            ctx.save(); ctx.rotate(-Math.PI/2); ctx.fillText("v", -vLen/2 - 10, r+20); ctx.restore();
        }

        ctx.restore(); // Undo rotation

        // Angular Velocity Indicator (Curved Arrow in Center)
        if(Math.abs(state.w) > 0.1) {
            let dir = state.w > 0 ? 1 : -1;
            ctx.strokeStyle = "#3498db"; ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(cx, cy, 40, -Math.PI/2, -Math.PI/2 + (dir * Math.PI), dir < 0); 
            ctx.stroke();
            // Arrowhead
            let tipX = cx + 40 * Math.cos(-Math.PI/2 + dir*Math.PI);
            let tipY = cy + 40 * Math.sin(-Math.PI/2 + dir*Math.PI);
            ctx.fillStyle = "#3498db"; ctx.beginPath(); ctx.arc(tipX, tipY, 6, 0, Math.PI*2); ctx.fill();
            ctx.fillText("ω", cx-5, cy-5);
        }
    }
    // ===============================================
    // === UNIT 2.4: STATIC VS KINETIC FRICTION ===
    // ===============================================
    function setup_2_4() {
        document.getElementById('sim-title').innerText = "2.4 Friction Graphing Lab";
        document.getElementById('sim-desc').innerHTML = `
            <h3>The Friction "Hump"</h3>
            <p>Static Friction (<span class="var">f<sub>s</sub></span>) matches your applied force until it reaches a maximum. 
            Once the object moves, Kinetic Friction (<span class="var">f<sub>k</sub></span>) takes over and is usually lower.
            <br><i>Slowly increase the Applied Force to see the break point!</i></p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Applied Force (<i class="var">F<sub>app</sub></i>): <span id="v-fa">0</span> N</label>
                <input type="range" id="in-fa" min="0" max="50" value="0" step="0.5" oninput="state.Fa=parseFloat(this.value); update_2_4()">
            </div>
            <div class="readout">
                Friction (<i class="var">f</i>): <span id="out-ff">0.0</span> N<br>
                Status: <span id="out-stat" style="font-weight:bold; color:red;">Static</span>
            </div>
            <button class="btn btn-red" onclick="reset_2_4()">Reset Graph</button>
        `;
        reset_2_4();
    }

    function reset_2_4() {
        state = {
            Fa: 0, 
            m: 5, 
            mu_s: 0.6, 
            mu_k: 0.4,
            v: 0, x: 0,
            graphData: [],
            running: true // Running logic handled in update
        };
        document.getElementById('in-fa').value = 0;
        update_2_4(); // Initial draw
    }

    function update_2_4() {
        if(currentSim !== '2.4') return;
        document.getElementById('v-fa').innerText = state.Fa;

        // Physics Calc
        let Fn = state.m * 9.8;
        let fs_max = state.mu_s * Fn;
        let fk = state.mu_k * Fn;

        let friction = 0;

        if (state.v === 0) {
            // STATIC REGION
            if (state.Fa <= fs_max) {
                friction = state.Fa;
                document.getElementById('out-stat').innerText = "Static (Not Moving)";
                document.getElementById('out-stat').style.color = "#c0392b";
            } else {
                // BREAKS LOOSE
                state.v = 0.1; // Start moving
            }
        } 

        if (state.v > 0) {
            // KINETIC REGION
            friction = fk;
            document.getElementById('out-stat').innerText = "Kinetic (Sliding)";
            document.getElementById('out-stat').style.color = "#27ae60";

            // Accel
            let Fnet = state.Fa - fk;
            state.v += (Fnet / state.m) * 0.1;
            state.x += state.v * 0.1;
        }

        document.getElementById('out-ff').innerText = friction.toFixed(1);

        // Add to graph (F_app vs Friction)
        // We plot F_app on X, Friction on Y
        state.graphData.push({x: state.Fa, y: friction});

        draw_2_4();
    }

    function draw_2_4() {
        ctx.clearRect(0,0,700,450);

        // Split Screen: Visual Top, Graph Bottom

        // --- TOP: THE BLOCK ---
        ctx.fillStyle = "#f0f3f5"; ctx.fillRect(0,0,700,200);
        ctx.beginPath(); ctx.moveTo(0,180); ctx.lineTo(700,180); ctx.stroke();

        let bx = 50 + (state.x % 600); // Wrap for infinite slide

        // Block
        ctx.fillStyle = "#e67e22"; ctx.fillRect(bx, 130, 50, 50);

        // Force Vectors
        // Applied (Right)
        if(state.Fa > 0) drawVector(bx+25, 155, state.Fa*3, 0, "black");
        // Friction (Left)
        let fVal = parseFloat(document.getElementById('out-ff').innerText);
        if(fVal > 0) drawVector(bx+25, 155, -fVal*3, 0, "red");

        // Microscopic View (Magnifying Glass)

        ctx.strokeStyle = "#7f8c8d"; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(bx+25, 180, 30, 0, Math.PI*2); ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.8)"; ctx.fill();
        // Teeth visualization
        ctx.beginPath(); 
        for(let i=-20; i<20; i+=5) {
            let offset = (state.v > 0) ? (Date.now()/50)%10 : 0; // Jiggle if moving
            ctx.moveTo(bx+25+i, 180); ctx.lineTo(bx+25+i+2, 175); // Top teeth
            ctx.moveTo(bx+25+i+offset, 180); ctx.lineTo(bx+25+i+2+offset, 185); // Bottom teeth
        }
        ctx.stroke();

        // --- BOTTOM: THE GRAPH ---
        ctx.fillStyle = "white"; ctx.fillRect(0,200,700,250);
        // Axes
        ctx.strokeStyle = "black"; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(50, 400); ctx.lineTo(650, 400); ctx.stroke(); // X (F_app)
        ctx.beginPath(); ctx.moveTo(50, 250); ctx.lineTo(50, 400); ctx.stroke(); // Y (F_frict)
        ctx.fillText("Applied Force (N)", 300, 430);
        ctx.save(); ctx.translate(30, 350); ctx.rotate(-Math.PI/2); ctx.fillText("Friction Force (N)", 0, 0); ctx.restore();

        // Plot Data
        ctx.strokeStyle = "blue"; ctx.lineWidth=3; ctx.beginPath();
        state.graphData.forEach((p, i) => {
            let px = 50 + p.x * 10;
            let py = 400 - p.y * 5;
            if(i==0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        });
        ctx.stroke();
    }


    // ===============================================
    // === UNIT 2.5: ELEVATOR PHYSICS ===
    // ===============================================
    function setup_2_5() {
        document.getElementById('sim-title').innerText = "2.5 Apparent Weight (Elevator)";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Normal Force in an Elevator</h3>
            <p>Your "Apparent Weight" is what a scale reads (<span class="var">F<sub>N</sub></span>).
            <br>Accelerating Up: <span class="var">F<sub>N</sub> = mg + ma</span> (Feel heavy).
            <br>Accelerating Down: <span class="var">F<sub>N</sub> = mg - ma</span> (Feel light).
            <br><i>Controls: Hold the buttons to accelerate.</i></p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Mass (<i class="var">m</i>): <span id="v-m">60</span> kg</label>
                <input type="range" id="in-m" min="40" max="100" value="60" oninput="reset_2_5()">
            </div>
            <div style="display:flex; gap:10px; margin-bottom:10px;">
                <button class="btn btn-green" onmousedown="state.a=2" onmouseup="state.a=0" onmouseleave="state.a=0">▲ Accel Up</button>
                <button class="btn btn-red" onmousedown="state.a=-2" onmouseup="state.a=0" onmouseleave="state.a=0">▼ Accel Down</button>
            </div>
            <div class="readout">
                Scale Reading (<i class="var">F<sub>N</sub></i>): <span id="out-fn">0</span> N
            </div>
            <div class="readout">
                Current Accel (<i class="var">a</i>): <span id="out-a">0</span> m/s²
            </div>
        `;
        reset_2_5();
    }

    function reset_2_5() {
        state = { m: parseFloat(document.getElementById('in-m').value), a: 0, v: 0, y: 225, running: true };
        document.getElementById('v-m').innerText = state.m;
        loop_2_5();
    }

    function loop_2_5() {
        if(!state.running || currentSim !== '2.5') return;

        // Update physics
        state.v += state.a * 0.05;
        state.y -= state.v * 0.5; // Visual movement (inverted Y)

        // Limits
        if(state.y < 50) { state.y = 50; state.v = 0; }
        if(state.y > 400) { state.y = 400; state.v = 0; }

        // Calc Forces
        let Fg = state.m * 9.8;
        let Fn = state.m * (9.8 + state.a);

        document.getElementById('out-fn').innerText = Math.round(Fn);
        document.getElementById('out-a').innerText = state.a;

        // Color Feedback for weight
        let readout = document.getElementById('out-fn');
        if(state.a > 0) readout.style.color = "red";       // Heavy
        else if(state.a < 0) readout.style.color = "blue"; // Light
        else readout.style.color = "black";                // Normal

        draw_2_5(Fg, Fn);
        animId = requestAnimationFrame(loop_2_5);
    }

    function draw_2_5(Fg, Fn) {
        ctx.clearRect(0,0,700,450);

        // Elevator Shaft
        ctx.fillStyle = "#34495e"; ctx.fillRect(200, 0, 300, 450);

        // Elevator Car
        ctx.fillStyle = "#ecf0f1"; ctx.fillRect(220, state.y, 260, 200);
        ctx.strokeStyle = "#bdc3c7"; ctx.lineWidth=5; ctx.strokeRect(220, state.y, 260, 200);

        // Person / Stick Figure
        let cx = 350; 
        let feetY = state.y + 190;

        // Scale
        ctx.fillStyle = "#95a5a6"; ctx.fillRect(cx-20, feetY, 40, 10);

        // Body

        ctx.strokeStyle = "black"; ctx.lineWidth=3;
        ctx.beginPath(); 
        ctx.moveTo(cx, feetY); ctx.lineTo(cx, feetY-60); // Legs
        ctx.moveTo(cx, feetY-60); ctx.lineTo(cx, feetY-110); // Torso
        ctx.moveTo(cx-20, feetY-90); ctx.lineTo(cx+20, feetY-90); // Arms
        ctx.stroke();
        ctx.beginPath(); ctx.arc(cx, feetY-125, 15, 0, Math.PI*2); ctx.stroke(); // Head

        // Free Body Diagram Arrows (Next to person)
        let fbdX = 550;
        let fbdY = 225;

        // Dot
        ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(fbdX, fbdY, 5, 0, Math.PI*2); ctx.fill();

        // Gravity (Down, constant length)
        drawVector(fbdX, fbdY, 0, 80, "#27ae60");
        ctx.fillStyle = "#27ae60"; ctx.fillText("Fg", fbdX+10, fbdY+40);

        // Normal Force (Up, varies)
        // Scale it: 80px = mg (normal weight)
        let fnLen = (Fn / Fg) * 80;
        drawVector(fbdX, fbdY, 0, -fnLen, "#c0392b");
        ctx.fillStyle = "#c0392b"; ctx.fillText("Fn", fbdX+10, fbdY-fnLen/2);
    }
    // ===============================================
    // === UNIT 3.3: VERTICAL CIRCULAR MOTION (Loop) ===
    // ===============================================
    function setup_3_3() {
        document.getElementById('sim-title').innerText = "3.3 Vertical Circular Motion";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Forces in a Vertical Loop</h3>
            <p>In a vertical loop, Gravity (<span class="var">F<sub>g</sub></span>) and Normal Force (<span class="var">F<sub>N</sub></span>) work together to provide centripetal force.
            <br><b>Top:</b> <span class="var">F<sub>net</sub> = F<sub>N</sub> + F<sub>g</sub></span>.
            <br><b>Bottom:</b> <span class="var">F<sub>net</sub> = F<sub>N</sub> - F<sub>g</sub></span>.
            <br><i>Watch what happens to F<sub>N</sub> if velocity is too low!</i></p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Radius (<i class="var">r</i>): <span id="v-r">5</span> m</label>
                <input type="range" id="in-r" min="3" max="8" value="5" oninput="reset_3_3()">
            </div>
            <div class="control-group">
                <label>Velocity (<i class="var">v</i>): <span id="v-v">10</span> m/s</label>
                <input type="range" id="in-v" min="5" max="20" value="10" oninput="reset_3_3()">
            </div>
            <div class="readout">Normal Force (<i class="var">F<sub>N</sub></i>): <span id="out-fn">0</span> N</div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_3_3()">Start / Stop</button>
        `;
        reset_3_3();
    }

    function reset_3_3() {
        state = {
            r: parseFloat(document.getElementById('in-r').value),
            v: parseFloat(document.getElementById('in-v').value),
            m: 100, // kg (Roller coaster cart)
            angle: -Math.PI / 2, // Start at bottom
            running: false,
            crashed: false
        };
        document.getElementById('v-r').innerText = state.r;
        document.getElementById('v-v').innerText = state.v;
        draw_3_3();
    }

    function loop_3_3() {
        if(!state.running || currentSim !== '3.3') return;
        
        // Angular velocity w = v/r
        let w = state.v / state.r;
        state.angle += w * 0.05; // Time step

        // Physics Calc
        let g = 9.8;
        // Height relative to center (-r to +r) - actually sin component
        let sinTheta = Math.sin(state.angle); 
        
        // Centripetal Force required: Fc = mv^2/r
        let Fc = (state.m * state.v * state.v) / state.r;
        
        // Radial component of Gravity: Fg_radial = mg * sin(theta)
        // Note: At top (sin=1), gravity points down (inward). At bottom (sin=-1), gravity points down (outward).
        // Let's stick to standard angle: 0 = Right, PI/2 = Bottom... No, let's use standard unit circle.
        // Top is 3PI/2 (270) or -PI/2? Visuals are easier if Top is -PI/2 in canvas y.
        // Let's calculate purely based on position:
        // Top: Fn + Fg = Fc  -> Fn = Fc - Fg
        // Bottom: Fn - Fg = Fc -> Fn = Fc + Fg
        
        // General: Fn = Fc - Fg_radial_inward
        // Fg is always down. Fg_radial_inward = -mg * sin(angle) (if angle 0 is right, -PI/2 is top)
        let Fg_inward = state.m * g * Math.sin(state.angle); 
        // Wait, at top (-PI/2), sin is -1. We want Fg inward (+) at top.
        // Let's fix coordinate system: Top of canvas loop is angle = -PI/2.
        
        let Fn = Fc - (state.m * 9.8 * Math.sin(state.angle));
        
        // At top (-PI/2), sin is -1. Fn = Fc - (-mg) = Fc + mg? No.
        // Top: Gravity helps Fc. Fn needs to do less work. Fn = Fc - Fg.
        // Let's just use vector logic for the readout text to simplify.
        // Top check:
        let isTop = Math.abs(state.angle % (2*Math.PI) - (-Math.PI/2)) < 0.5;
        
        // If Fn < 0 at the top, it falls (Critical velocity check)
        // v_min = sqrt(gr)
        let v_min = Math.sqrt(9.8 * state.r);
        
        // Actual Fn calculation for display:
        // Top: Fn = m(v^2/r) - mg
        // Bottom: Fn = m(v^2/r) + mg
        // Side: Fn = m(v^2/r)
        // Continuous: Fn = m(v^2/r) + mg * sin(angle)  <-- Assuming angle -PI/2 is top... 
        // Correct: Fn = mv²/r - mg*sin(theta) where theta is -PI/2 at top.
        // If sin(-90) = -1... Fn = Fc - (-mg) = Fc + mg. WRONG.
        // Let's keep it simple: Fg always points down.
        
        let Fg_down = state.m * 9.8;
        let vertical_component = Math.sin(state.angle); // -1 at top, 1 at bottom (canvas coords)
        
        // Canvas Y increases downwards.
        // Top of loop: Y is low. Angle -PI/2. Sin = -1.
        // Gravity acts DOWN (+Y). Radial vector is UP (-Y). Gravity opposes Center.
        // So at Top, Gravity is IN to center.
        
        let exactFn = Fc - (Fg_down * -Math.sin(state.angle)); 
        
        // Crash Check
        if (exactFn < 0) {
            state.running = false;
            state.crashed = true;
            document.getElementById('out-fn').innerText = "CRASH (v too low)";
        } else {
            document.getElementById('out-fn').innerText = Math.round(exactFn) + " N";
        }

        draw_3_3();
        if(!state.crashed) animId = requestAnimationFrame(loop_3_3);
    }

    function draw_3_3() {
        ctx.clearRect(0,0,700,450);
        
        let cx = 350, cy = 250;
        let pxScale = 30; // 30px = 1m
        let rPx = state.r * pxScale;
        
        // Track
        ctx.beginPath(); ctx.strokeStyle = "#555"; ctx.lineWidth = 10;
        ctx.arc(cx, cy, rPx, 0, Math.PI*2); ctx.stroke();
        
        // Ground
        ctx.fillStyle = "#2c3e50"; ctx.fillRect(0, cy + rPx + 5, 700, 20);

        // Cart Position
        let cartX = cx + rPx * Math.cos(state.angle);
        let cartY = cy + rPx * Math.sin(state.angle);

        if(state.crashed) {
            // Draw falling cart
            cartY += 20; 
            ctx.fillStyle = "red"; ctx.fillText("CRASH!", cx-20, cy);
        }

        // Draw Cart
        ctx.save();
        ctx.translate(cartX, cartY);
        ctx.rotate(state.angle + Math.PI/2); // Align with track
        
        ctx.fillStyle = state.crashed ? "#c0392b" : "#e67e22";
        ctx.fillRect(-15, -10, 30, 20); // Cart body
        ctx.fillStyle = "black";
        ctx.beginPath(); ctx.arc(-10, 10, 4, 0, Math.PI*2); ctx.fill(); // Wheels
        ctx.beginPath(); ctx.arc(10, 10, 4, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // Vectors (Only if not crashed)
        if (!state.crashed) {
            // Gravity (Always Down)
            drawVector(cartX, cartY, 0, 50, "#27ae60"); // Green Fixed Size
            
            // Normal Force (Towards Center)
            let FnVal = parseFloat(document.getElementById('out-fn').innerText);
            if(!isNaN(FnVal)) {
                let scaleFn = FnVal / 50; // Visual scaling
                if(scaleFn > 100) scaleFn = 100; // Cap visual size
                
                let normAngle = state.angle + Math.PI; // Inward
                drawVector(cartX, cartY, scaleFn*Math.cos(normAngle), scaleFn*Math.sin(normAngle), "#2980b9"); // Blue
            }
        }
    }


    // ===============================================
    // === UNIT 4.2: WORK & POWER ===
    // ===============================================
    function setup_4_2() {
        document.getElementById('sim-title').innerText = "4.2 Work & Power";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Calculating Work</h3>
            <p>Work is the transfer of energy: <span class="var">W = Fd cos&theta;</span>.
            <br>Only the component of force parallel to the displacement does work.
            <br>Power is the rate of work: <span class="var">P = W / t</span>.</p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Force (<i class="var">F</i>): <span id="v-f">20</span> N</label>
                <input type="range" id="in-f" min="0" max="50" value="20" oninput="reset_4_2()">
            </div>
            <div class="control-group">
                <label>Angle (<i class="var">&theta;</i>): <span id="v-a">0</span>&deg;</label>
                <input type="range" id="in-a" min="0" max="90" value="0" oninput="reset_4_2()">
            </div>
             <div class="control-group">
                <label>Distance (<i class="var">d</i>): <span id="v-d">10</span> m</label>
                <input type="range" id="in-d" min="5" max="20" value="10" oninput="reset_4_2()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_4_2()">Pull Block</button>
            <button class="btn btn-red" onclick="reset_4_2()">Reset</button>
            <div class="readout">Work: <span id="out-w">0</span> J | Power: <span id="out-p">0</span> W</div>
        `;
        reset_4_2();
    }

    function reset_4_2() {
        state = {
            F: parseFloat(document.getElementById('in-f').value),
            ang: parseFloat(document.getElementById('in-a').value),
            targetD: parseFloat(document.getElementById('in-d').value),
            x: 0, t: 0, running: false, finished: false
        };
        // Calc theoretical Work
        let rad = state.ang * Math.PI / 180;
        state.W_total = state.F * state.targetD * Math.cos(rad);
        
        document.getElementById('v-f').innerText = state.F;
        document.getElementById('v-a').innerText = state.ang;
        document.getElementById('v-d').innerText = state.targetD;
        document.getElementById('out-w').innerText = "0";
        document.getElementById('out-p').innerText = "0";
        
        draw_4_2();
    }

    function loop_4_2() {
        if(!state.running || currentSim !== '4.2' || state.finished) return;
        
        // Move block
        let dt = 0.05;
        state.t += dt;
        
        // Arbitrary speed based on F (F=ma logic simplified for demo)
        // a = Fx / m. Let m = 10.
        let rad = state.ang * Math.PI / 180;
        let Fx = state.F * Math.cos(rad);
        let a = Fx / 10; 
        if(a < 0.5) a = 0.5; // Min speed to ensure it moves
        
        let v = a * state.t;
        state.x += v * dt;

        // Current Work
        let currentD = state.x;
        if(currentD > state.targetD) {
            currentD = state.targetD;
            state.finished = true;
            state.running = false;
        }

        let W = state.F * currentD * Math.cos(rad);
        let P = W / state.t;

        document.getElementById('out-w').innerText = W.toFixed(1);
        document.getElementById('out-p').innerText = P.toFixed(1);

        draw_4_2();
        if(!state.finished) animId = requestAnimationFrame(loop_4_2);
    }

    function draw_4_2() {
        ctx.clearRect(0,0,700,450);
        ctx.fillStyle = "#f0f3f5"; ctx.fillRect(0,0,700,450);

        // Floor
        ctx.beginPath(); ctx.moveTo(0, 300); ctx.lineTo(700, 300); ctx.stroke();
        // Distance Markers
        ctx.fillStyle = "#7f8c8d";
        for(let i=0; i<=state.targetD; i+=5) {
            let mx = 50 + i*30;
            ctx.fillRect(mx, 300, 2, 10);
            ctx.fillText(i+"m", mx-5, 325);
        }

        // Block
        let bx = 50 + state.x * 30; // Scale 30px = 1m
        let by = 260;
        ctx.fillStyle = "#e67e22"; ctx.fillRect(bx, by, 40, 40);
        
        // Pull Vector
        let rad = state.ang * Math.PI / 180;
        let forceLen = state.F * 2; 
        let endX = bx + 20 + forceLen * Math.cos(-rad);
        let endY = by + 20 + forceLen * Math.sin(-rad);
        
        drawVector(bx+20, by+20, endX-(bx+20), endY-(by+20), "black");
        
        // Component Vector (Ghost)
        ctx.setLineDash([5,5]);
        drawVector(bx+20, by+20, (endX-(bx+20)), 0, "rgba(0,0,0,0.3)"); // Fx
        ctx.setLineDash([]);
        
        // Finish Line
        let fx = 50 + state.targetD * 30;
        ctx.strokeStyle = "red"; ctx.beginPath(); ctx.moveTo(fx, 200); ctx.lineTo(fx, 300); ctx.stroke();
        ctx.fillStyle = "red"; ctx.fillText("FINISH", fx-15, 190);
    }
    // ===============================================
    // === UNIT 4.3: ELASTIC POTENTIAL ENERGY ===
    // ===============================================
    function setup_4_3() {
        document.getElementById('sim-title').innerText = "4.3 Elastic Potential Energy";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Spring Energy Conversion</h3>
            <p>Compressing a spring stores Potential Energy (<span class="var">U<sub>s</sub> = &frac12;kx<sup>2</sup></span>).
            <br>When released, this energy converts to Kinetic Energy (<span class="var">K = &frac12;mv<sup>2</sup></span>).
            <br><i>Compress the spring and fire the block!</i></p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Spring Constant (<i class="var">k</i>): <span id="v-k">50</span> N/m</label>
                <input type="range" id="in-k" min="10" max="100" value="50" oninput="reset_4_3()">
            </div>
            <div class="control-group">
                <label>Compression (<i class="var">x</i>): <span id="v-x">0.5</span> m</label>
                <input type="range" id="in-x" min="0.1" max="1.0" step="0.1" value="0.5" oninput="reset_4_3()">
            </div>
            <div class="control-group">
                <label>Block Mass (<i class="var">m</i>): <span id="v-m">0.5</span> kg</label>
                <input type="range" id="in-m" min="0.1" max="2.0" step="0.1" value="0.5" oninput="reset_4_3()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_4_3()">Fire!</button>
            <button class="btn btn-red" onclick="reset_4_3()">Reset</button>
            <div class="readout">Exit Velocity: <span id="out-v">0.0</span> m/s</div>
        `;
        reset_4_3();
    }

    function reset_4_3() {
        state = {
            k: parseFloat(document.getElementById('in-k').value),
            comp: parseFloat(document.getElementById('in-x').value),
            m: parseFloat(document.getElementById('in-m').value),
            x: 0, // Current block pos relative to equilibrium
            v: 0,
            released: false,
            running: false
        };
        // Initial pos is negative compression
        state.x = -state.comp;
        
        document.getElementById('v-k').innerText = state.k;
        document.getElementById('v-x').innerText = state.comp;
        document.getElementById('v-m').innerText = state.m;
        document.getElementById('out-v').innerText = "0.0";
        draw_4_3();
    }

    function loop_4_3() {
        if(!state.running || currentSim !== '4.3') return;

        let dt = 0.02;
        
        if (state.x < 0) {
            // Spring Pushing Phase
            // a = F/m = (-kx)/m. Since x is negative, force is positive (right)
            let F = -state.k * state.x;
            let a = F / state.m;
            state.v += a * dt;
            state.x += state.v * dt;
        } else {
            // Coasting Phase (Left the spring)
            state.x += state.v * dt;
            document.getElementById('out-v').innerText = state.v.toFixed(2);
        }

        if(state.x > 5) state.running = false; // Off screen
        draw_4_3();
        animId = requestAnimationFrame(loop_4_3);
    }

    function draw_4_3() {
        ctx.clearRect(0,0,700,450);
        
        let wallX = 50;
        let eqX = 250; // Equilibrium position (x=0)
        let scale = 150; // 150px = 1m
        
        // Floor
        ctx.beginPath(); ctx.moveTo(0,300); ctx.lineTo(700,300); ctx.stroke();
        ctx.fillStyle = "#bdc3c7"; ctx.fillRect(0,300,700,20);
        
        // Wall
        ctx.fillStyle = "#7f8c8d"; ctx.fillRect(0, 200, wallX, 100);
        
        // Current Block Position (pixels)
        let blockPx = eqX + (state.x * scale);
        
        // Spring
        

[Image of spring potential energy diagram]

        ctx.beginPath(); ctx.strokeStyle = "#333"; ctx.lineWidth=3;
        let coils = 15;
        // Spring connects wallX to blockPx
        let springW = blockPx - wallX;
        let coilW = springW / coils;
        ctx.moveTo(wallX, 250);
        for(let i=0; i<=coils; i++) {
            ctx.lineTo(wallX + i*coilW, 250 + (i%2==0 ? 10 : -10));
        }
        ctx.stroke();
        
        // Block
        ctx.fillStyle = "#e67e22"; ctx.fillRect(blockPx, 230, 40, 70);
        
        // Energy Bar Chart (Live)
        let maxE = 0.5 * 100 * 1.0 * 1.0; // Benchmark max
        let Us = (state.x < 0) ? 0.5 * state.k * state.x * state.x : 0;
        let K = 0.5 * state.m * state.v * state.v;
        let Total = Us + K;
        
        let bx = 500, by = 150;
        let hScale = 100 / Total; // Normalize height to fit
        if(Total === 0) hScale = 0;
        
        // Draw Bars
        ctx.fillStyle = "#3498db"; ctx.fillRect(bx, by - Us*hScale, 30, Us*hScale); // Us
        ctx.fillStyle = "#2ecc71"; ctx.fillRect(bx+40, by - K*hScale, 30, K*hScale); // K
        
        ctx.fillStyle = "black";
        ctx.fillText("Us", bx+10, by+20);
        ctx.fillText("K", bx+50, by+20);
    }


    // ===============================================
    // === UNIT 2.6: DRAG & TERMINAL VELOCITY ===
    // ===============================================
    function setup_2_6() {
        document.getElementById('sim-title').innerText = "2.6 Drag & Terminal Velocity";
        document.getElementById('sim-desc').innerHTML = `
            <h3>Forces on a Falling Object</h3>
            <p>As velocity increases, Drag Force (<span class="var">F<sub>d</sub> = bv</span>) increases upwards.
            <br>Eventually, Drag equals Weight (<span class="var">F<sub>d</sub> = F<sub>g</sub></span>).
            <br>At this point, acceleration is zero and the object reaches <b>Terminal Velocity</b>.</p>`;

        document.getElementById('sim-controls').innerHTML = `
            <div class="control-group">
                <label>Mass (<i class="var">m</i>): <span id="v-m">70</span> kg</label>
                <input type="range" id="in-m" min="40" max="100" value="70" oninput="reset_2_6()">
            </div>
            <div class="control-group">
                <label>Drag Coeff (<i class="var">b</i>): <span id="v-b">0.5</span></label>
                <input type="range" id="in-b" min="0.1" max="2.0" step="0.1" value="0.5" oninput="reset_2_6()">
            </div>
            <button class="btn btn-green" onclick="state.running=!state.running; loop_2_6()">Drop</button>
            <button class="btn btn-red" onclick="reset_2_6()">Reset</button>
            <div class="readout">Vel: <span id="out-v">0.0</span> m/s | Accel: <span id="out-a">9.8</span> m/s²</div>
        `;
        reset_2_6();
    }

    function reset_2_6() {
        state = {
            m: parseFloat(document.getElementById('in-m').value),
            b: parseFloat(document.getElementById('in-b').value),
            v: 0, y: 50, t: 0,
            graphData: [],
            running: false
        };
        document.getElementById('v-m').innerText = state.m;
        document.getElementById('v-b').innerText = state.b;
        draw_2_6();
    }

    function loop_2_6() {
        if(!state.running || currentSim !== '2.6') return;

        let dt = 0.05;
        state.t += dt;
        
        // Forces
        let Fg = state.m * 9.8;     // Down (+)
        let Fd = state.b * state.v * 5; // Up (-), simplified linear drag
        
        let Fnet = Fg - Fd;
        let a = Fnet / state.m;
        
        state.v += a * dt;
        // Visual Y (wrap around)
        state.y += state.v * 0.1;
        if(state.y > 450) state.y = 0;

        // Data Update
        document.getElementById('out-v').innerText = state.v.toFixed(1);
        document.getElementById('out-a').innerText = a.toFixed(2);
        
        // Graph Data
        state.graphData.push({t: state.t, v: state.v});

        draw_2_6(Fg, Fd);
        animId = requestAnimationFrame(loop_2_6);
    }

    function draw_2_6(Fg, Fd) {
        ctx.clearRect(0,0,700,450);
        
        // Sky
        ctx.fillStyle = "#85c1e9"; ctx.fillRect(0,0,700,450);
        
        // Cloud Reference (Moving Up to simulate falling)
        let cloudY = (state.t * 20) % 500;
        ctx.fillStyle = "white"; 
        ctx.beginPath(); ctx.arc(100, 450-cloudY, 30, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(600, 200-cloudY, 40, 0, Math.PI*2); ctx.fill();

        // Skydiver
        let cx = 200, cy = 200; // Fixed visual position for FBD clarity
        
        

[Image of skydiver free body diagram]

        // Body
        ctx.fillStyle = "#34495e"; ctx.fillRect(cx-15, cy-20, 30, 40);
        ctx.beginPath(); ctx.arc(cx, cy-30, 10, 0, Math.PI*2); ctx.fill();
        
        // FBD Vectors
        // Gravity
        drawVector(cx, cy, 0, 80, "green"); // Constant
        ctx.fillStyle = "black"; ctx.fillText("Fg", cx+10, cy+40);
        
        // Drag (Grows)
        if(Fd) {
            let dragLen = (Fd / Fg) * 80; // Scale relative to gravity
            drawVector(cx, cy, 0, -dragLen, "red");
            ctx.fillText("Fd", cx+10, cy-dragLen);
        }

        // --- GRAPH ---
        let gx = 350, gy = 50, gw = 300, gh = 350;
        ctx.fillStyle = "rgba(255,255,255,0.8)"; ctx.fillRect(gx, gy, gw, gh);
        ctx.strokeStyle = "black"; ctx.strokeRect(gx, gy, gw, gh);
        
        // Plot v vs t
        ctx.strokeStyle = "blue"; ctx.lineWidth = 2; ctx.beginPath();
        let maxV = 100; // Scale
        state.graphData.forEach((p, i) => {
            let px = gx + p.t * 5;
            let py = (gy + gh) - (p.v / maxV) * gh;
            if (px < gx + gw) {
                if(i==0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
        });
        ctx.stroke();
        ctx.fillStyle = "black"; ctx.fillText("Velocity vs Time", gx+10, gy+20);
        
        // Terminal Velocity Line (dashed)
        let vt = (state.m * 9.8) / (state.b * 5);
        let vtY = (gy + gh) - (vt / maxV) * gh;
        ctx.strokeStyle = "green"; ctx.setLineDash([5,5]);
        ctx.beginPath(); ctx.moveTo(gx, vtY); ctx.lineTo(gx+gw, vtY); ctx.stroke();
        ctx.setLineDash([]);
    }
</script>

</body>
</html>
